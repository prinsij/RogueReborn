diff --git a/src/level.cpp b/src/level.cpp
index a5f9f31..af666b0 100644
--- a/src/level.cpp
+++ b/src/level.cpp
@@ -272,7 +272,8 @@ void Level::tryAddPassable(Coord current, std::queue<Coord>& q, Coord target){
 
 	if (target[0] > 0 && target[0] < size[0] && target[1] > 0 && target[1] < size[1]){
 
-		if(tiles[target[0]][target[1]].isPassable() == Terrain::Passable && !(tiles[target[0]][target[1]].checked)){
+		if(tiles[target[0]][target[1]].isPassable() == Terrain::Passable && !(tiles[target[0]][target[1]].checked)
+			&& !monsterAt(target)){
 
 			Coord c_ = current.copy();
 			Coord p_ = target.copy();
diff --git a/src/monster.cpp b/src/monster.cpp
index 7fd20e7..d7b2cfe 100644
--- a/src/monster.cpp
+++ b/src/monster.cpp
@@ -162,12 +162,16 @@ std::vector<char> Monster::getSymbolsForTreasure(int depth) {
 }
 
 void Monster::relocate(Level* level) {
+
+	//this->location = level->bfsDiag(this->location, )
+
 	if (Generator::randBool()) {
 		std::vector<Coord> possibleCoords = level->getAdjPassable(this->location);
 		if (possibleCoords.size()) {
 			this->location = possibleCoords[Generator::intFromRange(0, possibleCoords.size())];
 		}
 	}
+	
 }
 
 int Monster::turn(Level* level) {
diff --git a/src/playstate.cpp b/src/playstate.cpp
index ce59b59..62a8ae7 100644
--- a/src/playstate.cpp
+++ b/src/playstate.cpp
@@ -1,28 +1,17 @@
-/**
- * @file playstate.cpp
- * @author Team Rogue++
- * @date November 09, 2016
- *
- * @brief Member definitions for the PlayState class
- */ 
-
-#include <algorithm>
-#include <iostream>
-#include <string>
-
-#include "include/feature.h"
-#include "include/globals.h"
-#include "include/goldpile.h"
-#include "include/helpscreen.h"
-#include "include/invscreen.h"
-#include "include/item.h"
-#include "include/level.h"
-#include "include/playerchar.h"
 #include "include/playstate.h"
+#include "include/uistate.h"
+#include "include/playerchar.h"
+#include "include/level.h"
 #include "include/ripscreen.h"
+#include "include/helpscreen.h"
+#include "include/invscreen.h"
 #include "include/stairs.h"
-#include "include/uistate.h"
+#include "include/feature.h"
+#include "include/item.h"
+#include "include/goldpile.h"
 #include "libtcod/include/libtcod.hpp"
+#include <iostream>
+#include <string>
 
 /* The game can prompt the user for response.
  * This is blocking, but the level view remains.
@@ -117,41 +106,34 @@ void PlayState::draw(TCODConsole* con) {
 	for (auto x=0; x < level->getSize()[0]; x++) {
 		for (auto y=0; y < level->getSize()[1]; y++) {
 			auto mapPos = Coord(x, y);
-			Terrain& ter = (*level)[mapPos];
+			Terrain ter = (*level)[mapPos];
 			if (ter.isSeen() == Terrain::Seen) {
 				auto scrPos = mapPos.asScreen();
 				con->putChar(scrPos[0], scrPos[1], (*level)[mapPos].getSymbol());
-				for (Feature* feat : level->getFeatures()) {
-					if (feat->getLocation() == mapPos) {
-						con->putChar(scrPos[0], scrPos[1], feat->getSymbol());
-					}
-				}
-				int sightRadius = player->getSightRadius();
-				if (currRoom == NULL || currRoom->getDark() == Room::DARK) {
-					sightRadius = 1;
-				}
-				// Previously but not currently seen
-				if (mapPos.distanceTo(player->getLocation()) > sightRadius &&
+				if (mapPos.distanceTo(player->getLocation()) > player->getSightRadius() &&
 					(currRoom == NULL || !currRoom->contains(mapPos, 1))) {
 					con->setCharForeground(scrPos[0], scrPos[1], TCODColor::grey);
-				// Currently in view
-				} else {
-					for (Mob* mob : level->getMobs()) {
-						if (mob->getLocation() == mapPos) {
-							con->putChar(scrPos[0], scrPos[1], mob->getSymbol());
-						}
-					}
 				}
 			}
 		}
 	}
-
+	
 	// Display the prompt
 	if (prompt != NULL) {
 		prompt->showText(con, 0, 1);
 	} else if (player->getLog().size() > 0) {
 		con->print(0, 0, player->getLog().back().c_str());
 	}
+	// Display the features
+	for (Feature* feat : level->getFeatures()) {
+		auto scrPos = feat->getLocation().asScreen();
+		con->putChar(scrPos[0], scrPos[1], feat->getSymbol());
+	}
+	// Display the mobs
+	for (Mob* mob : level->getMobs()) {
+		auto scrPos = mob->getLocation().asScreen();
+		con->putChar(scrPos[0], scrPos[1], mob->getSymbol());
+	}
 	// Display the info bar
 	const int y = Coord(0, level->getSize()[1]).asScreen()[1]+1;
 	con->print(0, y, (
@@ -176,15 +158,25 @@ UIState* PlayState::handleInput(TCOD_key_t key) {
 		return this;
 	}
 	// Perform AI turns until it's the player's go
+	
+	int breaker = 10000;
+
 	while (true) {
 		auto nextUp = level->popTurnClock();
+
+		breaker--;
+
 		if (nextUp == player) {
-			level->pushMob(player, 0);
 			break;
 		}
-		//std::cout << "taking turn: " << nextUp->getName() << "\n";
+
+		else if (breaker == 0){
+			std::cout << "There has been an AI ERROR" << std::endl;
+			break;
+		}
+
 		// Do AI turn
-		level->pushMob(nextUp, nextUp->turn(level));
+		level->pushMob(nextUp, 50);
 	}
 	// Quitting
 	if (key.c == 'Q') {
@@ -197,28 +189,6 @@ UIState* PlayState::handleInput(TCOD_key_t key) {
 	if (key.c == '?') {
 		return new HelpScreen(player, level);
 	}
-	// Rest action
-	if (key.c == '.') {
-		level->pushMob(player, TURN_TIME);
-		player->appendLog("You rest briefly");
-		return this;
-	}
-	if (key.c == '<' || key.c == '>') {
-		for (Feature* feat : level->getFeatures()) {
-			Stairs* stair = dynamic_cast<Stairs*>(feat);
-			if (stair != NULL) {
-				if ((key.c == '>') == stair->getDirection()) {
-					int currDepth = level->getDepth();
-					delete level;
-					level = new Level(currDepth+1);
-					level->registerMob(player);
-					level->generate(*player);
-					currRoom = updateMap();
-					return this;
-				}
-			}
-		}
-	}
 	//Arrow controls
 	auto newPos = player->getLocation().copy();
 	if (key.vk == TCODK_UP) {
@@ -230,48 +200,31 @@ UIState* PlayState::handleInput(TCOD_key_t key) {
 	} else if (key.vk == TCODK_RIGHT) {
 		newPos += Coord(1, 0);
 	}
-	if (newPos != player->getLocation() && level->contains(newPos)) {
-		Mob* mob = level->monsterAt(newPos);
-		if (mob != NULL) {
-			std::cout << mob->getHP();
-			player->appendLog("attacked " + mob->getName());
-			if (mob->setCurrentHP(mob->getHP()-player->calculateDamage())) {
-				level->removeMob(mob);
-				player->appendLog(mob->getName() + " died, horribly");
-				delete mob;
+	if (newPos != player->getLocation() && level->contains(newPos) && (*level)[newPos].isPassable()) {
+		player->setLocation(newPos);
+		currRoom = updateMap();
+		for (Feature*& feat : level->getFeatures()) {
+			if (feat->getLocation() != newPos) {
+				continue;
+			}
+			Item* i = dynamic_cast<Item*>(feat);
+			if (i != NULL) {
+				player->pickupItem(i);
+				continue;
+			}
+			GoldPile* gp = dynamic_cast<GoldPile*>(feat);
+			if (gp != NULL) {
+				player->collectGold(gp);
+				feat = NULL;
+				continue;
+			}
+			Stairs* st = dynamic_cast<Stairs*>(feat);
+			if (st != NULL) {
+				std::cout << "transition level\n";
 			}
-			level->pushMob(player, TURN_TIME);
-		} else if ((*level)[newPos].isPassable()) {
-			player->setLocation(newPos);
-			level->pushMob(player, TURN_TIME);
-			//std::cout << "taking turn: " << player->getName() << "\n";
-			currRoom = updateMap();
-			bool search;
-			do {
-				search = false;
-				for (Feature* feat : level->getFeatures()) {
-					if (feat->getLocation() != newPos) {
-						continue;
-					}
-					Item* i = dynamic_cast<Item*>(feat);
-					if (i != NULL) {
-						player->pickupItem(i);
-						level->removeFeature(feat);
-						search = true;
-						break;
-					}
-					GoldPile* gp = dynamic_cast<GoldPile*>(feat);
-					if (gp != NULL) {
-						player->collectGold(gp);
-						level->removeFeature(feat);
-						delete feat;
-						search = true;
-						break;
-					}
-				}
-			} while (search);
 		}
 	}
+	level->pushMob(player, 50);
 	return this;
 }
 
