\documentclass[12pt, titlepage]{article}


% Packages


\usepackage{acronym}
\usepackage{booktabs}
\usepackage[usenames, dvipsnames]{color}
\usepackage{float}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{multirow}
\usepackage[round]{natbib}
\usepackage{tabularx}


% Setup


\definecolor{DarkBlue}{rgb}{0.1, 0.2, 0.5}

\hypersetup{
  colorlinks,
  citecolor=blue,
  filecolor=ForestGreen,
  linkcolor=DarkBlue,
  urlcolor=blue
}

\lstset{
  basicstyle=\ttfamily\footnotesize
}


% Custom Commands

\newcommand{\newSection}[1]{
  \newpage
  \section{#1}
}


\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}
%\newcommand{\acref}[1]{A Ref}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}
%\newcommand{\ucref}[1]{U Ref}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}
%\newcommand{\mref}[1]{M Ref}


% Title Page Elements


\title{SE 3XA3: Module Guide\\Rogue Reborn}

\author{Group \#6, Team Rogue++\\\\
  \begin{tabular} {l r}
  Ian Prins & prinsij \\
  Mikhail Andrenkov & andrem5 \\
  Or Almog & almogo
  \end{tabular}
}

\date{Due Friday, November 11\textsuperscript{th}, 2016}

\input{../../Comments}

\begin{document}

% Document Summary

\maketitle

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures

\begin{table}[bp]
	\caption{\bf Revision History}
	\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
		\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
		\midrule
		11/01/16 & 0.1 & Added Template\\
		\bottomrule
	\end{tabularx}
\end{table}

\newpage
\pagenumbering{arabic}

\newSection{Introduction}

Hello World!

\newSection{Anticipated and Unlikely Changes} \label{SecChange}

	This section lists possible changes to the system. According to the likeliness of the change, the possible changes are classified into two	categories. Anticipated changes are listed in Section \ref{SecAchange}, and unlikely changes are listed in Section \ref{SecUchange}.

	\subsection{Anticipated Changes} \label{SecAchange}

		Anticipated changes are the source of the information that is to be hidden inside the modules. Ideally, changing one of the anticipated changes will only require changing the one module that hides the associated decision. The approach adapted here is called design for change.

		\bigskip\begin{description}
			\item[\refstepcounter{acnum} \actheacnum \label{acHardware}:] The specific hardware on which the software is running.
			\item[\refstepcounter{acnum} \actheacnum \label{acInput}:] The format of the initial input data.
			\item ...
		\end{description}

	\subsection{Unlikely Changes} \label{SecUchange}

		The module design should be as general as possible. However, a general system is more complex. Sometimes this complexity is not necessary. Fixing some design decisions at the system architecture stage can simplify the software design. If these decision should later need to be changed, then many parts of the design	will potentially need to be modified. Hence, it is not intended that these decisions will be changed.

		\bigskip\begin{description}
			\item[\refstepcounter{ucnum} \uctheucnum \label{ucIO}:] Input/Output devices(Input: File and/or Keyboard, Output: File, Memory, and/or Screen).
			\item[\refstepcounter{ucnum} \uctheucnum \label{ucInput}:] There will always be a source of input data external to the software.
			\item ...
		\end{description}

\newSection{Module Hierarchy} \label{SecMH}

	This section provides an overview of the module design. Modules are summarized in a hierarchy decomposed by secrets in Table \ref{TblMH}. The modules listed below, which are leaves in the hierarchy tree, are the modules that will actually be implemented.

	\bigskip\begin{description}
	\item [\refstepcounter{mnum} \mthemnum \label{mHH}:] Hardware-Hiding Module
	\item ...
	\end{description}


	\begin{table}[h!]
		\centering
		\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
			\toprule
			\textbf{Level 1} & \textbf{Level 2}\\
			\midrule

			{Hardware-Hiding Module} & ~ \\
			\midrule

			\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} & ?\\
			& ?\\
			& ?\\
			& ?\\
			& ?\\
			& ?\\
			& ?\\ 
			& ?\\
			\midrule

			\multirow{3}{0.3\textwidth}{Software Decision Module} & {?}\\
			& ?\\
			& ?\\
			\bottomrule

		\end{tabular}
		\caption{Module Hierarchy}
		\label{TblMH}
	\end{table}

\newSection{Connection Between Requirements and Design} \label{SecConnection}

	The design of the system is intended to satisfy the requirements developed in the SRS. In this stage, the system is decomposed into modules. The connection between requirements and modules is listed in Table \ref{TblRT}.

\newSection{Module Decomposition} \label{SecMD}

	Modules are decomposed according to the principle of ``information hiding'' proposed by \citet{ParnasEtAl1984}. The \emph{Secrets} field in a module decomposition is a brief statement of the design decision hidden by the module. The \emph{Services} field specifies \emph{what} the module will do without documenting \emph{how} to do it. For each module, a suggestion for the implementing software is given under the \emph{Implemented By} title. If the entry is \emph{OS}, this means that the module is provided by the operating system or by standard programming language libraries.  Also indicate if themodule will be implemented specifically for the software.

	Only the leaf modules in the hierarchy have to be implemented. If a dash (\emph{--}) is shown, this means that the module is not a leaf and will not have to be implemented. Whether or not this module is implemented depends on the programming language selected.

	\subsection{Hardware Hiding Modules (\mref{mHH})}

		\bigskip\begin{description}
			\item[Name:]BasicIO.
			\item[Secrets:]Input and output devices.
			\item[Services:]Serves as a layer beneath our application hiding the specifics of the
			input and output devices such as keystrokes and the monitor. The application uses it
			to retrieve commands from the user and display the game state.
			\item[Implemented By:] Libtcod library.
		\end{description}

	\subsection{Behaviour-Hiding Module}

		\bigskip\begin{description}
			\item[Name:]Random.
			\item[Secrets:]The details of random number generation.
			\item[Services:]Provides utilities to the rest of the application for the generation of random
			values. The algorithm used or the state of the PRNG are not exposed.
			\item[Implemented By:] random.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]External.
			\item[Secrets:]The contents of the required behaviours.
			\item[Services:]Includes programs that provide externally visible behaviour of the system as specified in the software requirements specification (SRS) documents. This module serves as a communication layer between the hardware-hiding module and the software decision module. The programs in this module will need to change if there are changes in the SRS.
			\item[Implemented By:] --
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Doryen.
			\item[Secrets:]Details of display device and OS window interface.
			\item[Services:]Provides a virtual console interface to the application. The virtual console is displayed as a window in the host OS. The application uses the interface to display the game state.
			\item[Implemented By:]Libtcod
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Level.
			\item[Secrets:]Data storage format of the dungeon level.
			\item[Services:]Shields the rest of the application from the level data structure, providing methods that conveniently implement the details of operations. This also allows the underlying structures to change freely.
			\item[Implemented By:]level.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]LevelGen.
			\item[Secrets:]Level generation algorithm.
			\item[Services:]Used by the controller modules to generate levels without requiring them to know the details of the algorithm.
			\item[Implemented By:]level.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Item.
			\item[Secrets:]Item data structures and behavior.
			\item[Services:]Provides a consistent interface across all items, shielding the application from the details of the various types' internals. The application can move, activate, destroy, identify, or otherwise manipulate items freely using this module.
			\item[Implemented By:]item.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]UIState.
			\item[Secrets:]State of game interface.
			\item[Services:]Layer between the game user and the game world. Handles command interpretation and menu control. Passes user commands to implementing modules.
			\item[Implemented By:]uistate.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]MasterController.
			\item[Secrets:]Game loop and application context.
			\item[Services:]Directs the high-level flow of rendering, input-handling, and transitions between lower-level controllers. The flow between uistate.h members is modeled as a finite state machine.
			\item[Implemented By:]mastercontroller.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]RipScreen.
			\item[Secrets:]Scoring and score storage.
			\item[Services:]Handles reading and writing from the score file, and the contents thereof. The nature and location of the score table is known only to this module.
			\item[Implemented By:]ripscreen.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Terrain.
			\item[Secrets:]Data structures of a dungeon tile.
			\item[Services:]Stores the data for a single dungeon tile. This includes the character representing it, it's passability, transparency, and whether it is mapped.
			\item[Implemented By:]terrain.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]ItemZone.
			\item[Secrets:]Data structures storing items.
			\item[Services:]Stores items and provides an interface mapping key-codes to specific items. Shields the application from details such as key-code ,and item stacking. 
			\item[Implemented By:]itemzone.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Mob.
			\item[Secrets:]Internal data structures and behavior of creatures.
			\item[Services:]Base module for all creatures in the dungeon (including the character). Provides interfaces for movement, combat, and various statistics.
			\item[Implemented By:]mob.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Monster.
			\item[Secrets:]Monster data and algorithms implementing monster behavior.
			\item[Services:]Customizes the behavior of various monsters to be greedy, fly, be aggressive, regenerate, etc. Also stores the data that defines the various monsters that can be found in the dungeon. eg. a dragon has certain behavior, a name, a certain quantity of hitpoints, etc.
			\item[Implemented By:]monster.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Coord.
			\item[Secrets:]Coordinate representation and coordinate related behavior
			\item[Services:]Provides a consistent interface for all other modules to use to communicate about the locations of objects within the level and on the screen. Also implements related algorithms such as the taxicab distance between two coordinates.
			\item[Implemented By:]coord.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Feature.
			\item[Secrets:]Data structures implementing various objects found in the dungeon.
			\item[Services:]Stores the data for any object found in the dungeon which is not a mob. This includes various objects such as stairs, piles of gold, items, and traps.
			\item[Implemented By:]feature.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]NNNNNNNNNNN.
			\item[Secrets:]
			\item[Services:]
			\item[Implemented By:]
		\end{description}

	\subsubsection{Input Format Module (\mref{mInput})}

		\bigskip\begin{description}
			\item[Name:]NNNNNNNNNNN.
			\item[Secrets:]Interface to input devices.
			\item[Services:]Detects keystrokes and provides virtual keycodes to the application. These are then interpreted by the system as commands from the user.
			\item[Implemented By:] Libtcod
		\end{description}

		\bigskip\begin{description}
			\item[Name:]NNNNNNNNNNN.
			\item[Secrets:]The format and structure of the input data.
			\item[Services:]Converts the input data into the data structure used by the input parameters module.
			\item[Implemented By:] [Your Program Name Here]
		\end{description}

	  \subsubsection{Etc.}

	\subsection{Software Decision Module}

		\bigskip\begin{description}
			\item[Name:]NNNNNNNNNNN.
			\item[Secrets:] The design decision based on mathematical theorems, physical facts, or programming considerations. The secrets of this module are \emph{not} described in the SRS.
			\item[Services:] Includes data structure and algorithms used in the system that do not provide direct interaction with the user. 
			  % Changes in these modules are more likely to be motivated by a desire to improve performance than by externally imposed changes.
			\item[Implemented By:] --
		\end{description}

	  \subsubsection{Etc.}

\newSection{Traceability Matrix} \label{SecTM}

	This section shows two traceability matrices: between the modules and the
	requirements and between the modules and the anticipated changes.

	% the table should use mref, the requirements should be named, use something like fref
	\begin{table}[H]
		\centering
		\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}

			\toprule
			\textbf{Req.} & \textbf{Modules}\\
			\midrule

			R1 & \mref{mHH}, \mref{mInput}, \mref{mParams}, \mref{mControl}\\
			R2 & \mref{mInput}, \mref{mParams}\\
			R3 & \mref{mVerify}\\
			R4 & \mref{mOutput}, \mref{mControl}\\
			R5 & \mref{mOutput}, \mref{mODEs}, \mref{mControl}, \mref{mSeqDS}, \mref{mSolver}, \mref{mPlot}\\
			R6 & \mref{mOutput}, \mref{mODEs}, \mref{mControl}, \mref{mSeqDS}, \mref{mSolver}, \mref{mPlot}\\
			R7 & \mref{mOutput}, \mref{mEnergy}, \mref{mControl}, \mref{mSeqDS}, \mref{mPlot}\\
			R8 & \mref{mOutput}, \mref{mEnergy}, \mref{mControl}, \mref{mSeqDS}, \mref{mPlot}\\
			R9 & \mref{mVerifyOut}\\
			R10 & \mref{mOutput}, \mref{mODEs}, \mref{mControl}\\
			R11 & \mref{mOutput}, \mref{mODEs}, \mref{mEnergy}, \mref{mControl}\\

			\bottomrule
		\end{tabular}

		\caption{Trace Between Requirements and Modules}
		\label{TblRT}
	\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}

		\toprule
		\textbf{AC} & \textbf{Modules}\\
		\midrule

		\acref{acHardware} & \mref{mHH}\\
		\acref{acInput} & \mref{mInput}\\
		\acref{acParams} & \mref{mParams}\\
		\acref{acVerify} & \mref{mVerify}\\
		\acref{acOutput} & \mref{mOutput}\\
		\acref{acVerifyOut} & \mref{mVerifyOut}\\
		\acref{acODEs} & \mref{mODEs}\\
		\acref{acEnergy} & \mref{mEnergy}\\
		\acref{acControl} & \mref{mControl}\\
		\acref{acSeqDS} & \mref{mSeqDS}\\
		\acref{acSolver} & \mref{mSolver}\\
		\acref{acPlot} & \mref{mPlot}\\

		\bottomrule
	\end{tabular}

	\caption{Trace Between Anticipated Changes and Modules}
	\label{TblACT}
\end{table}

\newSection{Use Hierarchy Between Modules} \label{SecUse}

	In this section, the uses hierarchy between modules is provided. \citet{Parnas1978} said of two programs A and B that A {\em uses} B if correct execution of B may be necessary for A to complete the task described in its specification. That is, A {\em uses} B if there exist situations in which the correct functioning of A depends upon the availability of a correct implementation of B.  Figure \ref{FigUH} illustrates the use relation between the modules. It can be seen that the graph is a directed acyclic graph (DAG). Each level of the hierarchy offers a testable and usable subset of the system, and modules in the higher level of the hierarchy are essentially simpler because they use modules from the lower levels.

	\begin{figure}[H]
		\centering
		%\includegraphics[width=0.7\textwidth]{UsesHierarchy.png}
		\caption{Use hierarchy among modules}
		\label{FigUH}
	\end{figure}

\newSection{References}

	\bibliographystyle {plainnat}
	\bibliography {MG}

\end{document}