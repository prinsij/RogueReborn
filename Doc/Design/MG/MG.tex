\documentclass[12pt, titlepage]{article}


% Packages


\usepackage{acronym}
\usepackage{booktabs}
\usepackage[usenames, dvipsnames]{color}
\usepackage{float}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{multirow}
\usepackage[round]{natbib}
\usepackage{tabularx}


% Setup


\definecolor{DarkBlue}{rgb}{0.1, 0.2, 0.5}

\hypersetup{
  colorlinks,
  citecolor=blue,
  filecolor=ForestGreen,
  linkcolor=DarkBlue,
  urlcolor=blue
}

\lstset{
  basicstyle=\ttfamily\footnotesize
}


% Custom Commands

\newcommand{\newSection}[1]{
  \newpage
  \section{#1}
}


\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}
%\newcommand{\acref}[1]{A Ref}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}
%\newcommand{\ucref}[1]{U Ref}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}
%\newcommand{\mref}[1]{M Ref}


% Title Page Elements


\title{SE 3XA3: Module Guide\\Rogue Reborn}

\author{Group \#6, Team Rogue++\\\\
  \begin{tabular} {l r}
  Ian Prins & prinsij \\
  Mikhail Andrenkov & andrem5 \\
  Or Almog & almogo
  \end{tabular}
}

\date{Due Friday, November 11\textsuperscript{th}, 2016}

\input{../../Comments}

\begin{document}

% Document Summary

\maketitle

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures

\begin{table}[bp]
	\caption{\bf Revision History}
	\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
		\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
		\midrule
		11/01/16 & 0.1 & Added Template\\
		11/10/16 & 0.2 & Finished part 2\\
		\bottomrule
	\end{tabularx}
\end{table}

\newpage
\pagenumbering{arabic}

\newSection{Introduction}

Hello World!

\newSection{Anticipated and Unlikely Changes} \label{SecChange}

	This section lists possible changes to the system. According to the likeliness of the change, the possible changes are classified into two	categories. Anticipated changes are listed in Section \ref{SecAchange}, and unlikely changes are listed in Section \ref{SecUchange}.

	\subsection{Anticipated Changes} \label{SecAchange}

		Anticipated changes are the source of the information that is to be hidden inside the modules. Ideally, changing one of the anticipated changes will only require changing the one module that hides the associated decision. The approach adapted here is called design for change.

		\bigskip\begin{description}
			\item[\refstepcounter{acnum} \actheacnum \label{acHardware}:] The specific hardware on which the software is running.
			\item[\refstepcounter{acnum} \actheacnum \label{acOs}:] The operating system on which the program will be executed.
			\item[\refstepcounter{acnum} \actheacnum \label{acLanguage}:] The language in which the game is presented.
			\item[\refstepcounter{acnum} \actheacnum \label{acAccessibility}:] Accessibility modifications used to play the game.
			\item[\refstepcounter{acnum} \actheacnum \label{acItems}:] The items available in the game (i.e. addition of a new potion).
			\item[\refstepcounter{acnum} \actheacnum \label{acMonsters}:] The number, type, and visualization of monsters.
			\item[\refstepcounter{acnum} \actheacnum \label{acVisuals}:] The graphical overlay of the game (Different graphical overlays could be used to alter the images displayed).
		\end{description}

	\subsection{Unlikely Changes} \label{SecUchange}

		The module design should be as general as possible. However, a general system is more complex. Sometimes this complexity is not necessary. Fixing some design decisions at the system architecture stage can simplify the software design. If these decision should later need to be changed, then many parts of the design	will potentially need to be modified. Hence, it is not intended that these decisions will be changed.

		\bigskip\begin{description}
			\item[\refstepcounter{ucnum} \uctheucnum \label{ucMasterCtrl}:] The way the game loop handles itself, in the context of in-game entities, state parameters, and high-level flow. Just about every single module in the program will have to change to accommodate for this change.
			\item[\refstepcounter{ucnum} \uctheucnum \label{ucTerrain}:] The types of terrain in the game, expressed in terms of passability, transparency, and visibility. A change here will also involve a change in Level, LevelGen, and PlayerChar.
			\item[\refstepcounter{ucnum} \uctheucnum \label{ucCoord}:] The way in which the coordinate system of the game functions. A change here will involve changing just about every single module in the system.
			\item[\refstepcounter{ucnum} \uctheucnum \label{ucRooms}:] The number of rooms in a dungeon level. Modifying this will involve immersive changes to the Level module, as well as the entire Item chain, and of course LevelGen module.
		\end{description}

\newSection{Module Hierarchy} \label{SecMH}

	This section provides an overview of the module design. Modules are summarized in a hierarchy decomposed by secrets in Table \ref{TblMH}. The modules listed below, which are leaves in the hierarchy tree, are the modules that will actually be implemented.

	\bigskip\begin{description}
	\item [\refstepcounter{mnum} \mthemnum \label{mHH}:] Hardware-Hiding Module
	\item ...
	\end{description}


	\begin{table}[h!]
		\centering
		\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
			\toprule
			\textbf{Level 1} & \textbf{Level 2}\\
			\midrule

			\multirow{2}{0.3\textwidth}{Hardware-Hiding Module}
			& BasicIO\\
			& Doryen\\
			\midrule

			\multirow{5}{0.3\textwidth}{Behaviour-Hiding Module}
			& LevelGen\\
			& Item\\
			& Monster\\
			& RipScreen\\
			& PlayerChar\\
			\midrule

			\multirow{9}{0.3\textwidth}{Software Decision Module}
			& Random\\
			& UIState\\
			& Level\\
			& MasterController\\
			& Terrain\\
			& Itemzone\\
			& Mob\\
			& Coord\\
			& Feature\\
			\bottomrule

		\end{tabular}
		\caption{Module Hierarchy}
		\label{TblMH}
	\end{table}

\newSection{Connection Between Requirements and Design} \label{SecConnection}

	%The design of the system is intended to satisfy the requirements developed in the SRS. In this stage, the system is decomposed into modules. The connection between requirements and modules is listed in Table \ref{TblRT}.
	
	The relationship between system design and requirements is delicate - while every module may contain one secret, this secret may involve multiple functional/non-functional requirements. The decisions that went into the design of the system were made based on two major factors:

	\begin{itemize}
		\item Flexibility: Should any feature be decided as non-feasible, out-of-scope, or otherwise unattainable, the system should not collapse due to its lacking.
		\item Logical partitioning: We tried to keep related logic as close together as possible. One could argue that this was done to adhere with the concept of "one module, one secret", but that in fact is not the case. The OMOS concept is simply a consequence of the duality of "High cohesion, low coupling". This was, succinctly, the deciding factor in our system design stage.
	\end{itemize}

	The requirements are numerous, and identifying each requirements' correspondence to a module would be quite the bore. Instead, we will look at important requirements and how they interact interestingly with their corresponding modules.\\

	Functional requirement 11 specifies: "The player character shall be able to pass their turn". Had this not been the case, a simple queue could be built to keep track of entity move order and that will be all. But this is not the case, and in fact this also ties along with functional requirement 35, which specifies "Each monster shall be able to calculate a plan of action during their turn." Different actions take different amounts of time, and it would be a poor design decision to assume the opposite. A smart, divisive system was built to take this into account and enable turn-skipping. A primary motive that is enabled by this feature is allowing the player to skip their turn, allowing a nearby monster to make a move, hopefully into the region into which the player can fire off projectiles, like arrows and vials. The module that handles all of this functionality is titled \textit{MasterController}.\\

	Functional requirement 37 specifies: "The player character shall be able to defeat every monster." It may be assumed, at this point, that a monster may be defeated if its health drops below zero. The entire functionality of absorbing player damage and reporting the results is handled by the \textit{Mob} module. Why not \textit{Monster}, you ask? Well, the Monster module is designed to customize monster behavior, such as attack patterns, and combative positioning. The Mob module, on the other hand, provides an interface for movement and entity statistics, which includes hit points.\\

	Finally, we will look at functional requirement 31, which specifies: "Scrolls, rings, and wans shall be usable". This requirement represents one of the most difficult aspects of the game. Every different scroll, ring, and wand has a different functionality. And while all may be used in very similar ways, the core function is vastly different. While a purple wand may zap a goblin out of existence, a topaz ring might cause the player to suddenly begin levitating in the air. Thoroughly inter-connected aspects of the game are affected by items, and they represent a very central aspect of the project. This is why items are given their own module, \textit{Item}, to manage items and shield their detailed functionalities.\\



\newSection{Module Decomposition} \label{SecMD}

	Modules are decomposed according to the principle of ``information hiding'' proposed by \citet{ParnasEtAl1984}. The \emph{Secrets} field in a module decomposition is a brief statement of the design decision hidden by the module. The \emph{Services} field specifies \emph{what} the module will do without documenting \emph{how} to do it. For each module, a suggestion for the implementing software is given under the \emph{Implemented By} title. If the entry is \emph{OS}, this means that the module is provided by the operating system or by standard programming language libraries.  Also indicate if themodule will be implemented specifically for the software.

	Only the leaf modules in the hierarchy have to be implemented. If a dash (\emph{--}) is shown, this means that the module is not a leaf and will not have to be implemented. Whether or not this module is implemented depends on the programming language selected.

	\subsection{Hardware Hiding Modules (\mref{mHH})}

		\bigskip\begin{description}
			\item[Name:]BasicIO.
			\item[Secrets:]Input and output devices.
			\item[Services:]Serves as a layer beneath our application hiding the specifics of the
			input and output devices such as keystrokes and the monitor. The application uses it
			to retrieve commands from the user and display the game state.
			\item[Implemented By:]Libtcod library.
		\end{description}

	\subsection{Behaviour-Hiding Module}

		\bigskip\begin{description}
			\item[Name:]Random.
			\item[Secrets:]The details of random number generation.
			\item[Services:]Provides utilities to the rest of the application for the generation of random
			values. The algorithm used or the state of the PRNG are not exposed.
			\item[Implemented By:] random.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]External.
			\item[Secrets:]The contents of the required behaviours.
			\item[Services:]Includes programs that provide externally visible behaviour of the system as specified in the software requirements specification (SRS) documents. This module serves as a communication layer between the hardware-hiding module and the software decision module. The programs in this module will need to change if there are changes in the SRS.
			\item[Implemented By:] --
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Doryen.
			\item[Secrets:]Details of display device and OS window interface.
			\item[Services:]Provides a virtual console interface to the application. The virtual console is displayed as a window in the host OS. The application uses the interface to display the game state.
			\item[Implemented By:]Libtcod library.
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Level.
			\item[Secrets:]Data storage format of the dungeon level.
			\item[Services:]Shields the rest of the application from the level data structure, providing methods that conveniently implement the details of operations. This also allows the underlying structures to change freely.
			\item[Implemented By:]level.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]LevelGen.
			\item[Secrets:]Level generation algorithm.
			\item[Services:]Used by the controller modules to generate levels without requiring them to know the details of the algorithm.
			\item[Implemented By:]level.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Item.
			\item[Secrets:]Item data structures and behavior.
			\item[Services:]Provides a consistent interface across all items, shielding the application from the details of the various types' internals. The application can move, activate, destroy, identify, or otherwise manipulate items freely using this module.
			\item[Implemented By:]item.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]UIState.
			\item[Secrets:]State of game interface.
			\item[Services:]Layer between the game user and the game world. Handles command interpretation and menu control. Passes user commands to implementing modules.
			\item[Implemented By:]uistate.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]MasterController.
			\item[Secrets:]Game loop and application context.
			\item[Services:]Directs the high-level flow of rendering, input-handling, and transitions between lower-level controllers. The flow between uistate.h members is modeled as a finite state machine.
			\item[Implemented By:]mastercontroller.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]RipScreen.
			\item[Secrets:]Scoring and score storage.
			\item[Services:]Handles reading and writing from the score file, and the contents thereof. The nature and location of the score table is known only to this module.
			\item[Implemented By:]ripscreen.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Terrain.
			\item[Secrets:]Data structures of a dungeon tile.
			\item[Services:]Stores the data for a single dungeon tile. This includes the character representing it, it's passability, transparency, and whether it is mapped.
			\item[Implemented By:]terrain.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]ItemZone.
			\item[Secrets:]Data structures storing items.
			\item[Services:]Stores items and provides an interface mapping key-codes to specific items. Shields the application from details such as key-code ,and item stacking. 
			\item[Implemented By:]itemzone.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Mob.
			\item[Secrets:]Internal data structures and behavior of creatures.
			\item[Services:]Base module for all creatures in the dungeon (including the character). Provides interfaces for movement, combat, and various statistics.
			\item[Implemented By:]mob.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Monster.
			\item[Secrets:]Monster data and algorithms implementing monster behavior.
			\item[Services:]Customizes the behavior of various monsters to be greedy, fly, be aggressive, regenerate, etc. Also stores the data that defines the various monsters that can be found in the dungeon. eg. a dragon has certain behavior, a name, a certain quantity of hitpoints, etc.
			\item[Implemented By:]monster.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Coord.
			\item[Secrets:]Coordinate representation and coordinate related behavior
			\item[Services:]Provides a consistent interface for all other modules to use to communicate about the locations of objects within the level and on the screen. Also implements related algorithms such as the taxicab distance between two coordinates.
			\item[Implemented By:]coord.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]Feature.
			\item[Secrets:]Data structures implementing various objects found in the dungeon.
			\item[Services:]Stores the data for any object found in the dungeon which is not a mob. This includes various objects such as stairs, piles of gold, items, and traps.
			\item[Implemented By:]feature.h
		\end{description}

		\bigskip\begin{description}
			\item[Name:]NNNNNNNNNNN.
			\item[Secrets:]
			\item[Services:]
			\item[Implemented By:]
		\end{description}

	\subsubsection{Input Format Module (\mref{mInput})}

		\bigskip\begin{description}
			\item[Name:]NNNNNNNNNNN.
			\item[Secrets:]Interface to input devices.
			\item[Services:]Detects keystrokes and provides virtual keycodes to the application. These are then interpreted by the system as commands from the user.
			\item[Implemented By:]Libtcod library.
		\end{description}

		\bigskip\begin{description}
			\item[Name:]NNNNNNNNNNN.
			\item[Secrets:]The format and structure of the input data.
			\item[Services:]Converts the input data into the data structure used by the input parameters module.
			\item[Implemented By:] [Your Program Name Here]
		\end{description}

	  \subsubsection{Etc.}

	\subsection{Software Decision Module}

		\bigskip\begin{description}
			\item[Name:]NNNNNNNNNNN.
			\item[Secrets:] The design decision based on mathematical theorems, physical facts, or programming considerations. The secrets of this module are \emph{not} described in the SRS.
			\item[Services:] Includes data structure and algorithms used in the system that do not provide direct interaction with the user. 
			  % Changes in these modules are more likely to be motivated by a desire to improve performance than by externally imposed changes.
			\item[Implemented By:] --
		\end{description}

	  \subsubsection{Etc.}

\newSection{Traceability Matrix} \label{SecTM}

	This section shows two traceability matrices: between the modules and the
	requirements and between the modules and the anticipated changes.

	% the table should use mref, the requirements should be named, use something like fref
	\begin{table}[H]
		\centering
		\begin{tabular}{p{0.35\textwidth} p{0.45\textwidth}}

			\toprule
			\textbf{Req.} & \textbf{Modules}\\
			\midrule

			FR.1, FR.4, FR.7 & MasterController, Coord\\
			FR.2, FR.3 & RipScreen\\
			FR.6, FR.8, FR.9, FR.10 & UIState, Doryen, Coord\\
			FR.11, FR.12 & PlayerChar\\
			FR.13, FR.14, FR.15 & Feature\\
			FR.16 & MasterController\\
			FR.17, FR.18, FR.19, FR.25 & LevelGen, Coord\\
			FR.20, FR.21, FR.22, FR.24 & Level, Coord\\
			FR.23 & PlayerChar\\
			FR.26, FR.27, Fr.28, Fr.29 & PlayerChar\\
			FR.30, FR.31 & Item\\
			FR.32, FR.33, FR.34 & Item, PlayerChar\\
			Fr.35, FR.36 & Monster\\
			FR.37 & Mob\\
			FR.38, FR.39 & PlayerChar\\
			\midrule
			NFR.1 & Doryen, UIState\\
			NFR.2 & Fun\\
			NFR.3 & BasicIO\\
			NFR.4, NFR.5 & UIState, Doryen\\
			NFR.7 & MasterController\\
			NFR.8, NFR.13 & RipScreen\\
			NFR.9, NFR.12, NFR.15 & External\\

			\bottomrule
		\end{tabular}

		\caption{Trace Between Requirements and Modules}
		\label{TblRT}
	\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}

		\toprule
		\textbf{AC} & \textbf{Modules}\\
		\midrule
		\acref{acHardware} & BasicIO, External, Random\\
		\acref{acOs} & BasicIO, External, Doryen\\
		\acref{acLanguage} & BasicIO, UIState\\
		\acref{acAccessibility} & UIState, BasicIO\\
		\acref{acItems} & Item, Feature, PlayerChar, Mob\\
		\acref{acMonsters} & Monster, Mob, UIState\\
		\acref{acVisual} & UIState, External\\

		\bottomrule
	\end{tabular}

	\caption{Trace Between Anticipated Changes and Modules}
	\label{TblACT}
\end{table}

\newSection{Use Hierarchy Between Modules} \label{SecUse}

	In this section, the uses hierarchy between modules is provided. \citet{Parnas1978} said of two programs A and B that A {\em uses} B if correct execution of B may be necessary for A to complete the task described in its specification. That is, A {\em uses} B if there exist situations in which the correct functioning of A depends upon the availability of a correct implementation of B.  Figure \ref{FigUH} illustrates the use relation between the modules. It can be seen that the graph is a directed acyclic graph (DAG). Each level of the hierarchy offers a testable and usable subset of the system, and modules in the higher level of the hierarchy are essentially simpler because they use modules from the lower levels.

	\begin{figure}[H]
		\centering
		%\includegraphics[width=0.7\textwidth]{UsesHierarchy.png}
		\caption{Use hierarchy among modules}
		\label{FigUH}
	\end{figure}

\newSection{References}

	\bibliographystyle {plainnat}
	\bibliography {MG}

\end{document}