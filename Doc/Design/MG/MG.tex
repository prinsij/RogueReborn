\documentclass[12pt, titlepage]{article}


% Packages


\usepackage{acronym}
\usepackage{booktabs}
\usepackage[usenames, dvipsnames]{color}
\usepackage{float}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{multirow}
\usepackage[round]{natbib}
\usepackage{tabularx}


% Setup


\definecolor{DarkBlue}{rgb}{0.1, 0.2, 0.5}

\hypersetup{
  colorlinks,
  citecolor=blue,
  filecolor=ForestGreen,
  linkcolor=DarkBlue,
  urlcolor=blue
}

\lstset{
  basicstyle=\ttfamily\footnotesize
}


% Custom Commands

\newcommand{\newSection}[1]{
  \newpage
  \section{#1}
}


\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}


% Title Page Elements


\title{SE 3XA3: Module Guide\\Rogue Reborn}

\author{Group \#6, Team Rogue++\\\\
  \begin{tabular} {l r}
  Ian Prins & prinsij \\
  Mikhail Andrenkov & andrem5 \\
  Or Almog & almogo
  \end{tabular}
}

\date{Due Friday, November 11\textsuperscript{th}, 2016}

\input{../../Comments}

\begin{document}

% Document Summary

\maketitle

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures

\begin{table}[bp]
    \caption{\bf Revision History}
    \bigskip
    \begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
        \toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
        \midrule
        11/01/16 & 0.1 & Initial Template\\
        11/10/16 & 0.2 & Added Anticipated Changes\\
        11/12/16 & 0.3 & Added Module Decomposition\\
        11/12/16 & 0.4 & Added Introduction\\
        11/12/16 & 0.5 & Added Use Hierarchy\\
        \bottomrule
    \end{tabularx}
\end{table}

\newpage
\pagenumbering{arabic}


% Document Content


\newSection{Introduction} \label{SecIntro}

    \subsection{Project Overview}
        The Rogue Reborn project aims to develop a contemporary clone of the original \textit{Rogue} game by leveraging modern programming paradigms, development tools, and software engineering principles.  Aside from the executable, the Rogue++ team also plans to deliver a collection of commented source code, test suites, and formal documentation for both internal and public consumption.  In doing so, Rogue Reborn will serve as an open-source repository for other developers to view, comment, and contribute to the code and documentation that characterize the project in its entirety. 

    \subsection{Document Context}
        The primary purpose of the Module Guide (MG) is to describe, justify, and contextualize the module decomposition of the system.  From a developer perspective, the MG facilitates the detection of overused or purposeless modules and helps identify architectural flaws.  The document also provides a conceptual view of each module and its context in the broader system.\\

        Before the MG is written, the Software Requirements Specification (SRS) document should be completed and thoroughly reviewed by all stakeholder parties.  The SRS describes requirements for the software system that the MG should relate to the implemented design.  By completing the SRS beforehand, it is more likely that the selected system design will comply with all compulsory requirements and the chosen module decomposition is appropriately structured.\\

        After the MG is complete, the complementary Module Interface Specification (MIS) can be conceived to refine the interface (external behaviour) of each module.  The MG produces a functional overview of each module, while the MIS delves into the actual implementation of the modules.  Together, the MG and MIS are sufficient to allow programmers to concurrently develop the system in a modular fashion.  
    
    \subsection{Design Principles}
        In an effort to develop code that is robust, maintainable, and more easily verifiable, the Rogue Reborn project attempts to enforce several well-regard design principles.  In particular, the principles of Information Hiding (IH), High Cohesion (HC), and Low Coupling (LC) are consistently expressed throughout the code.\\

        Information Hiding refers to the practice of concealing the implementation of modules; this is typically accomplished through encapsulation.  Using this approach encourages developers to become more mindful of their assumptions and to produce code that does not depend on the specific implementations of various functions.  Next, High Cohesion and Low Coupling describe the practice of partitioning code into modules that contain related operations and do not rely heavily on other modules.  Modules that exhibit HC lend themselves to excellent error localization, while module systems that display LC are better suited for testing purposes.  Structuring programs to emphasizes adaptability and modularity is vital to the success of any long-term software project.

    \subsection{Design Document Structure}
        A brief description of each section in the Module Guide is given below:

        \begin{itemize}
            \item[] \hyperref[SecIntro]{\S1} Overview of the MG document
            \item[] \hyperref[SecChange]{\S2} Comprehensive list of system changes under consideration
            \item[] \hyperref[SecMH]{\S3} Conceptual hierarchy of implemented modules
            \item[] \hyperref[SecConnection]{\S4} Analysis of the system architecture design with respect to the mandated requirements
            \item[] \hyperref[SecMD]{\S5} Detailed summary of the module decomposition 
            \item[] \hyperref[SecTM]{\S6} Tabular depiction of the relationships between modules, requirements, and anticipated changes
            \item[] \hyperref[SecUse]{\S7} Illustration of the module functionality dependency graph
            \item[] \hyperref[SecRef]{\S8} References to external sources
        \end{itemize}

    \subsection{Acronyms and Definitions}
        \begin{table}[H]
            \centering
            \caption{\bf Acronyms}
            \label{TableAcronym}
            \bigskip
            \def\arraystretch{1.5}
            \begin{tabularx}{\textwidth}{p{3.7cm}X}
                \toprule
                \textbf{Acronym} & \textbf{Definition} \\
                \midrule
                AC & Anticipated Change\\
                ASCII & American Standard Code for Information Interchange\\
                DAG & Directed Acyclic Graph\\
                FR & Functional Requirement\\
                GUI & Graphical User Interface\\
                HC & High Cohesion\\
                IH & Information Hiding\\
                LC & Low Coupling\\
                LoS & Line of Sight\\
                MG & Module Guide\\
                MIS & Module Interface Specification\\
                NFR & Non-Functional Requirement\\
                OMOS & One Module One Secret\\
                OS & Operating System\\
                PoC & Proof of Concept\\
                PRNG & Pseudorandom Number Generator\\ 
                SRS & Software Requirements Specification\\
                UC & Unlikely Change\\
            \bottomrule
            \end{tabularx}
        \end{table}

        \begin{table}[H]
            \centering
            \caption{\bf Definitions}
            \label{TableDefinitions}
            \bigskip
            \def\arraystretch{1.5}
            \begin{tabularx}{\textwidth}{p{3.7cm}X}
                \toprule
                \textbf{Term} & \textbf{Definition}\\
                \midrule
                \textbf{Amulet of Yendor} & Item located on the deepest level of the dungeon; enables the player character to ascend through the levels and complete the game\\
                \textbf{Encapsulation} & Grouping together of methods and fields\\
                \textbf{Frame} & An instantaneous ``snapshot'' of the GUI screen\\
                \textbf{Homomorphism} & A mapping between two mathematical structures\\
                \textbf{Libtcod} & Graphics library specializing in delivering a roguelike experience\\
                \textbf{Permadeath} & Feature whereby the death of the player character will conclude the game\\
                \textbf{Player Character} & User-controlled character in Rogue Reborn\\
                \textbf{Rogue} & Video game developed for the UNIX terminal in 1980 that initiated the roguelike genre\\
                \textbf{Roguelike} & Genre of video games characterized by ASCII graphics, procedurally-generated levels, and permadeath\\
                \bottomrule
            \end{tabularx}
        \end{table} 

\newSection{Anticipated and Unlikely Changes} \label{SecChange}

    This section lists possible changes to the system. According to the likeliness of the change, the possible changes are classified into two  categories. Anticipated changes are listed in Section \ref{SecAchange}, and unlikely changes are listed in Section \ref{SecUchange}.

    \subsection{Anticipated Changes} \label{SecAchange}

        Anticipated changes are the source of the information that is to be hidden inside the modules. Ideally, changing one of the anticipated changes will only require changing the one module that hides the associated decision. The approach adapted here is called design for change.

        \bigskip\begin{description}
            \item[\refstepcounter{acnum} \actheacnum \label{acHardware}:] The specific hardware on which the software is running.
            \item[\refstepcounter{acnum} \actheacnum \label{acOs}:] The operating system on which the program will be executed.
            \item[\refstepcounter{acnum} \actheacnum \label{acLanguage}:] The language in which the game is presented.
            \item[\refstepcounter{acnum} \actheacnum \label{acAccessibility}:] Accessibility modifications used to play the game.
            \item[\refstepcounter{acnum} \actheacnum \label{acItems}:] The items available in the game (i.e. addition of a new potion).
            \item[\refstepcounter{acnum} \actheacnum \label{acMonsters}:] The number, type, and visualization of monsters.
            \item[\refstepcounter{acnum} \actheacnum \label{acVisuals}:] The graphical overlay of the game (Different graphical overlays could be used to alter the images displayed).
        \end{description}

    \subsection{Unlikely Changes} \label{SecUchange}

        The module design should be as general as possible. However, a general system is more complex. Sometimes this complexity is not necessary. Fixing some design decisions at the system architecture stage can simplify the software design. If these decision should later need to be changed, then many parts of the design will potentially need to be modified. Hence, it is not intended that these decisions will be changed.

        \bigskip\begin{description}
            \item[\refstepcounter{ucnum} \uctheucnum \label{ucMasterCtrl}:] The way the game loop handles itself, in the context of in-game entities, state parameters, and high-level flow. Just about every single module in the program will have to change to accommodate for this change.
            \item[\refstepcounter{ucnum} \uctheucnum \label{ucTerrain}:] The types of terrain in the game, expressed in terms of passability, transparency, and visibility. A change here will also involve a change in Level, LevelGen, and PlayerChar.
            \item[\refstepcounter{ucnum} \uctheucnum \label{ucCoord}:] The way in which the coordinate system of the game functions. A change here will involve changing just about every single module in the system.
            \item[\refstepcounter{ucnum} \uctheucnum \label{ucRooms}:] The number of rooms in a dungeon level. Modifying this will involve immersive changes to the Level module, as well as the entire Item chain, and of course LevelGen module.
        \end{description}

\newSection{Module Hierarchy} \label{SecMH}

    Modules are summarized in a hierarchy decomposed by secrets in Table \ref{TblMH}. The modules listed below, which are leaves in the hierarchy tree, are the modules that will actually be implemented.

    \begin{table}[h!]
        \caption{\bf Module Hierarchy}
        \label{TblMH}
        \bigskip
        \centering
        \begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
            \toprule
            \textbf{Level 1} & \textbf{Level 2}\\
            \midrule

            \multirow{2}{0.3\textwidth}{Hardware-Hiding Module}
            & BasicIO\\
            & Doryen\\
            \midrule

            \multirow{6}{0.3\textwidth}{Behaviour-Hiding Module}
            & External\\
            & Item\\
            & Level\\
            & LevelGen\\
            & MainMenu\\  
            & Monster\\
            & PlayerChar\\
            & RipScreen\\
            & PlayState\\
            & UIState\\
            \midrule

            \multirow{9}{0.3\textwidth}{Software Decision Module}
            & Coord\\
            & Feature\\
            & Itemzone\\          
            & MasterController\\            
            & Mob\\
            & Random\\
            & Terrain\\
            \bottomrule

        \end{tabular}
    \end{table}

\newSection{Connection Between Requirements and Design} \label{SecConnection}

    %The design of the system is intended to satisfy the requirements developed in the SRS. In this stage, the system is decomposed into modules. The connection between requirements and modules is listed in Table \ref{TblRT}.
    
    The relationship between system design and requirements is delicate - while every module may contain one secret, this secret may involve multiple functional/non-functional requirements. The decisions that went into the design of the system were made based on two major factors:

    \begin{itemize}
        \item Flexibility: Should any feature be decided as non-feasible, out-of-scope, or otherwise unattainable, the system should not collapse due to its lacking.
        \item Logical partitioning: We tried to keep related logic as close together as possible. One could argue that this was done to adhere with the concept of "one module, one secret", but that in fact is not the case. The OMOS concept is simply a consequence of the duality of "High cohesion, low coupling". This was, succinctly, the deciding factor in our system design stage.
    \end{itemize}

    The requirements are numerous, and identifying each requirements' correspondence to a module would be quite the bore. Instead, we will look at important requirements and how they interact interestingly with their corresponding modules.\\

    Functional requirement 11 specifies: "The player character shall be able to pass their turn". Had this not been the case, a simple queue could be built to keep track of entity move order and that will be all. But this is not the case, and in fact this also ties along with functional requirement 35, which specifies "Each monster shall be able to calculate a plan of action during their turn." Different actions take different amounts of time, and it would be a poor design decision to assume the opposite. A smart, divisive system was built to take this into account and enable turn-skipping. A primary motive that is enabled by this feature is allowing the player to skip their turn, allowing a nearby monster to make a move, hopefully into the region into which the player can fire off projectiles, like arrows and vials. The module that handles all of this functionality is titled \textit{MasterController}.\\

    Functional requirement 37 specifies: "The player character shall be able to defeat every monster." It may be assumed, at this point, that a monster may be defeated if its health drops below zero. The entire functionality of absorbing player damage and reporting the results is handled by the \textit{Mob} module. Why not \textit{Monster}, you ask? Well, the Monster module is designed to customize monster behavior, such as attack patterns, and combative positioning. The Mob module, on the other hand, provides an interface for movement and entity statistics, which includes hit points.\\

    Finally, we will look at functional requirement 31, which specifies: "Scrolls, rings, and wans shall be usable". This requirement represents one of the most difficult aspects of the game. Every different scroll, ring, and wand has a different functionality. And while all may be used in very similar ways, the core function is vastly different. While a purple wand may zap a goblin out of existence, a topaz ring might cause the player to suddenly begin levitating in the air. Thoroughly inter-connected aspects of the game are affected by items, and they represent a very central aspect of the project. This is why items are given their own module, \textit{Item}, to manage items and shield their detailed functionalities.\\



\newSection{Module Decomposition} \label{SecMD}

    \subsection{Hardware Hiding Modules}

        \bigskip\begin{description}
            \item[Name:]BasicIO
            \item[Secrets:]Input and output devices.
            \item[Services:]Serves as a layer beneath our application hiding the specifics of the input and output devices such as keystrokes and the monitor. The application uses it to retrieve commands from the user and display the game state.
            \item[Implemented By:]Libtcod library.
        \end{description}

        \bigskip\begin{description}
            \item[Name:]Doryen
            \item[Secrets:]Details of display device and OS window interface.
            \item[Services:]Provides a virtual console interface to the application. The virtual console is displayed as a window in the host OS. The application uses the interface to display the game state.
            \item[Implemented By:]Libtcod library.
        \end{description}

        \bigskip\begin{description}
            \item[Name:]Input Format
            \item[Secrets:]Interface to input devices.
            \item[Services:]Detects keystrokes and provides virtual keycodes to the application. These are then interpreted by the system as commands from the user. As a layer above the BasicIO module, it hides not only the hardware itself, but the design of the device, for example it could allow the use of a touch screen with virtual buttons.
            \item[Implemented By:]Libtcod library.
        \end{description}

    \subsection{Behaviour-Hiding Module}

        \bigskip\begin{description}
            \item[Name:]External
            \item[Secrets:]The method by which gamestate is translated into display.
            \item[Services:]All externally visible behavior passes through this module, as it controls the rendering of the game world. Interfaces between the hardware hiding modules by rendering onto them, and the software decision modules by making use of their data structures.
            \item[Implemented By:]uistate.h
        \end{description}

        \bigskip\begin{description}
            \item[Name:]Item
            \item[Secrets:]Item data structures and behavior.
            \item[Services:]Provides a consistent interface across all items, shielding the application from the details of the various types' internals. The application can move, activate, destroy, identify, or otherwise manipulate items freely using this module.
            \item[Implemented By:]item.h
        \end{description}

        \bigskip\begin{description}
            \item[Name:]Level
            \item[Secrets:]Data storage format of the dungeon level.
            \item[Services:]Shields the rest of the application from the level data structure, providing methods that conveniently implement the details of operations. This also allows the underlying structures to change freely.
            \item[Implemented By:]level.h
        \end{description}

        \bigskip\begin{description}
            \item[Name:]LevelGen
            \item[Secrets:]Level generation algorithm.
            \item[Services:]Used by the controller modules to generate levels without requiring them to know the details of the algorithm.
            \item[Implemented By:]level.h
        \end{description}

        \bigskip\begin{description}
            \item[Name:]MainMenu
            \item[Secrets:]Valid user name enforcement.
            \item[Services:]Accepts a legal player character name from the keyboard and initializes the player character.
            \item[Implemented By:]mainmenu.h
        \end{description}

        \bigskip\begin{description}
            \item[Name:]Monster
            \item[Secrets:]Monster data and algorithms implementing monster behavior.
            \item[Services:]Customizes the behavior of various monsters to be greedy, fly, be aggressive, regenerate, etc. Also stores the data that defines the various monsters that can be found in the dungeon. eg. a dragon has certain behavior, a name, a certain quantity of hitpoints, etc.
            \item[Implemented By:]monster.h
        \end{description}

        \bigskip\begin{description}
            \item[Name:]PlayState
            \item[Secrets:]Player character action selection.
            \item[Services:]Calls the appropriate PlayerChar action methods according to the user's input.  Renders the primary game screen.
            \item[Implemented By:]playstate.h
        \end{description}

        \bigskip\begin{description}
            \item[Name:]RipScreen
            \item[Secrets:]Scoring and score storage.
            \item[Services:]Handles reading and writing from the score file, and the contents thereof. The nature and location of the score table is known only to this module.
            \item[Implemented By:]ripscreen.h
        \end{description}

        \bigskip\begin{description}
            \item[Name:]UIState
            \item[Secrets:]State of game interface.
            \item[Services:]Layer between the game user and the game world. Handles command interpretation and menu control. Passes user commands to implementing modules.
            \item[Implemented By:]uistate.h
        \end{description}

    \subsection{Software Decision Module}

        \bigskip\begin{description}
            \item[Name:]Coord
            \item[Secrets:]Coordinate representation and coordinate related behavior
            \item[Services:]Provides a consistent interface for all other modules to use to communicate about the locations of objects within the level and on the screen. Also implements related algorithms such as the taxicab distance between two coordinates.
            \item[Implemented By:]coord.h
        \end{description}

        \bigskip\begin{description}
            \item[Name:]Feature
            \item[Secrets:]Data structures implementing various objects found in the dungeon.
            \item[Services:]Stores the data for any object found in the dungeon which is not a mob. This includes various objects such as stairs, piles of gold, items, and traps.
            \item[Implemented By:]feature.h
        \end{description}

        \bigskip\begin{description}
            \item[Name:]ItemZone
            \item[Secrets:]Data structures storing items.
            \item[Services:]Stores items and provides an interface mapping key-codes to specific items. Shields the application from details such as key-code ,and item stacking. 
            \item[Implemented By:]itemzone.h
        \end{description}

        \bigskip\begin{description}
            \item[Name:]MasterController
            \item[Secrets:]Game loop and application context.
            \item[Services:]Directs the high-level flow of rendering, input-handling, and transitions between lower-level controllers. The flow between uistate.h members is modeled as a finite state machine.
            \item[Implemented By:]mastercontroller.h
        \end{description}

        \bigskip\begin{description}
            \item[Name:]Mob
            \item[Secrets:]Internal data structures and behavior of creatures.
            \item[Services:]Base module for all creatures in the dungeon (including the character). Provides interfaces for movement, combat, and various statistics.
            \item[Implemented By:]mob.h
        \end{description}


        \bigskip\begin{description}
            \item[Name:]Random
            \item[Secrets:]The details of random number generation.
            \item[Services:]Provides utilities to the rest of the application for the generation of random
            values. The algorithm used or the state of the PRNG are not exposed.
            \item[Implemented By:] random.h
        \end{description}

        \bigskip\begin{description}
            \item[Name:]Terrain
            \item[Secrets:]Data structures of a dungeon tile.
            \item[Services:]Stores the data for a single dungeon tile. This includes the character representing it, it's passability, transparency, and whether it is mapped.
            \item[Implemented By:]terrain.h
        \end{description}

\newSection{Traceability Matrix} \label{SecTM}

    This section shows two traceability matrices: between the modules and the
    requirements and between the modules and the anticipated changes.

    % the table should use mref, the requirements should be named, use something like fref
    \begin{table}[H]
        \label{TblRT}
        \caption{\bf Trace Between Requirements and Modules}
        
        \def\arraystretch{1.1}
        \centering
        \bigskip
        \begin{tabular}{p{0.40\textwidth} p{0.60\textwidth}}

            \toprule
            \textbf{Requirements} & \textbf{Modules}\\
            \midrule

            FR.1, FR.4, FR.7 & MasterController, Coord\\
            FR.2, FR.3 & RipScreen\\
            FR.5 & MainMenu\\
            FR.6, FR.8, FR.9, FR.10 & UIState, Doryen, Coord, PlayState\\
            FR.11, FR.12 & PlayerChar\\
            FR.13, FR.14, FR.15 & Feature\\
            FR.16 & MasterController\\
            FR.17, FR.18, FR.19, FR.25 & LevelGen, Coord\\
            FR.20, FR.21, FR.22, FR.24 & Level, Coord\\
            FR.23 & PlayerChar\\
            FR.26, FR.27, FR.28, FR.29 & PlayerChar\\
            FR.30, FR.31 & Item\\
            FR.32, FR.33, FR.34 & Item, PlayerChar\\
            Fr.35, FR.36 & Monster\\
            FR.37 & Mob\\
            FR.38, FR.39 & PlayerChar\\
            \midrule
            NFR.1 & Doryen, UIState, PlayState\\
            NFR.2 & Fun\\
            NFR.3 & BasicIO\\
            NFR.4, NFR.5 & UIState, Doryen, PlayState\\
            NFR.7 & MasterController\\
            NFR.8, NFR.13 & RipScreen\\
            NFR.9, NFR.12, NFR.15 & External\\

            \bottomrule
        \end{tabular}
    \end{table}

\begin{table}[H] 
    \label{TblACT}
    \caption{\bf Trace Between Anticipated Changes and Modules}
    
    \def\arraystretch{1.1}
    \centering
    \bigskip
    \begin{tabular}{p{0.4\textwidth} p{0.6\textwidth}}

        \toprule
        \textbf{AC} & \textbf{Modules}\\
        \midrule
        \acref{acHardware} & BasicIO, External, Random\\
        \acref{acOs} & BasicIO, External, Doryen\\
        \acref{acLanguage} & BasicIO, UIState\\
        \acref{acAccessibility} & UIState, BasicIO\\
        \acref{acItems} & Item, Feature, PlayerChar, Mob\\
        \acref{acMonsters} & Monster, Mob, UIState\\
        \acref{acVisuals} & UIState, External\\

        \bottomrule
    \end{tabular}
\end{table}

\newSection{Use Hierarchy Between Modules} \label{SecUse}

    Within the software engineering discipline, there exists a widely-accepted belief that all Use Hierarchies must be homomorphic to directed acyclic graphs (DAGs) in order to avoid cyclic dependencies.  However, throughout the development of the Rogue Reborn project, the Rogue++ team discovered that a cyclic use relationship across certain modules enabled an architecture that closely resembled the natural flow of the intended interaction.  Although it would have been possible to correct the situation, the alternative designs would have an adverse effect on the high cohesion (HC) design principle and would sacrifice the maintainability and readability of the code.  As such, the Use Hierarchy drawn in Figure \hyperref[FigUH]{1} is illustrated with a cyclic dependency stemming from the \textit{Item} module.

    \begin{figure}[H]
        \label{FigUH}
        \caption{\bf Use Hierarchy}
        \centering
        \bigskip
        \includegraphics[width=0.85\textwidth]{./UH.png}
    \end{figure}

\newSection{References} \label{SecRef}

    %\bibliographystyle {plainnat}
    %\bibliography {MG}

\end{document}