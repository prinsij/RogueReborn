\documentclass[12pt, titlepage]{article}


% Packages

 
\usepackage{booktabs}
\usepackage{float}
\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{indentfirst}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{listings}
\usepackage[round]{natbib}
\usepackage[usenames, dvipsnames]{color}
\usepackage{tikz}
\usepackage{longtable}

% Setup

\hypersetup{
	colorlinks,
	citecolor=blue,
	filecolor=ForestGreen,
	linkcolor=MidnightBlue,
	urlcolor=blue
}

\lstset{
	basicstyle=\ttfamily\footnotesize
}

% Custom Commands

\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0em}}p{#1}}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0em}}p{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0em}}p{#1}}

\newcounter{mnum}
\newcommand{\mhprint}[2]{\addtocounter{mnum}{1} #1 & \textbf{M#2}}
\newcommand{\mdprint}[1]{\addtocounter{mnum}{1} #1 & \textbf{M\themnum}}

\newcommand{\newsection}[1]{
  \newpage
  \section{#1}
}

\newcommand{\nfrt}[1]{
	\textit{NFRT #1}
}

\newcommand{\nfrtc}[3]{
	\begin{center}
		\def\arraystretch{1.6}
		\begin{tabular}{| R{6em} L{23em} |}
			\bottomrule
			\multicolumn{2}{| c |}{\textbf{Non-Functional Requirement Test} \# #1 \textbf{Summary}}  \\
			\hline
			\textit{Description:} & #2 \\
			\textit{Results:} & #3 \\
			\toprule
		\end{tabular}
	\end{center}
}

% Title Page Elements

\title{SE 3XA3: Test Plan\\Rogue Reborn}

\author{Group \#6, Team Rogue++\\\\
	\begin{tabular}{lr}
		Ian Prins & prinsij \\
		Mikhail Andrenkov & andrem5 \\
		Or Almog & almogo
	\end{tabular}
}

\date{Due Wednesday, December 7\textsuperscript{th}, 2016}

\input{../Comments}
\pagenumbering{arabic}

\begin{document}


% Document Summary

\maketitle

\newpage
\tableofcontents

\newpage
\listoftables

\newpage
\listoffigures
\begin{table}[bp]
	\caption{\bf Revision History}
	\bigskip
	\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
		\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
		\midrule
		12/06/16 & 0.1 & Initial Draft\\
		12/06/16 & 0.2 & Automated Tests To PlayerChar\\
		12/06/16 & 0.3 & Functional Requirements Evaluation\\
		12/07/16 & 0.4 & Introduction\\
		12/07/16 & 0.5 & Finished Automated Tests\\
		\bottomrule
	\end{tabularx}
\end{table}

\newsection{Introduction} \label{Section_Intro}

	\subsection{Overview}
	The primary objective of this document is to provide a comprehensive summary of the verification process with respect to the Rogue Reborn project.  Interested parties are welcome to analyze this paper as a means of evaluating the success of the final application regarding the requirements described in the \href{run:../SRS/SRS.pdf}{SRS} and tests prescribed in the \href{run:../TestPlan/TestPlan.pdf}{Test Plan}.  After reviewing the document, the reader should understand the strengths and weaknesses of the Rogue Project as it relates to the expectations of the client.

	\subsection{Sections}
	A brief description of each Test Report section is provided below:

	\begin{itemize}
		\item [] \hyperref[Section_Intro]{\S 1} Brief overview of the Test Report
		\item [] \hyperref[Section_FR_Evaluation]{\S 2} Functional evaluation of Rogue Reborn
		\item [] \hyperref[Section_NFR_Evaluation]{\S 3} Non-functional evaluation of Rogue Reborn
		\item [] \hyperref[Section_Comparison]{\S 4} Description of relationship to original \textit{Rogue} with respect to testing 
		\item [] \hyperref[Section_UT]{\S 5} Explanation of unit testing in Rogue Reborn
		\item [] \hyperref[Section_Changes]{\S 6} List of changes that were performed as a consequence of testing
		\item [] \hyperref[Section_Automated]{\S 7} Tabular depiction of automated tests
		\item [] \hyperref[Section_R_Trace]{\S 8} Justification of test files with respect to functional requirements
		\item [] \hyperref[Section_M_Trace]{\S 9} Decomposition of modules and trace to test files
		\item [] \hyperref[Section_Metrics]{\S 10} Summary of code coverage metrics

	\end{itemize}

\newsection{Functional Requirements Evaluation} \label{Section_FR_Evaluation}
	Overall, an evaluation of functional requirements reveals near, if not complete coverage. The tests written for the projects turned out to be quite useful, as many caught bugs or business-errors that would have otherwise gone unnoticed. Those will be discussed below. As for the rest of the functional requirements, many were mundane, general, or crucial enough to have already been satisfied earlier. Those will not be discussed, as their complete satisfaction has already been verified countless times.\\

	The list below refers to each functional requirement by its numerical identifier, as listed in the System Requirements Specification. Please refer to the \href{run:../SRS/SRS.pdf}{SRS} document if any confusion arises.

	\begin{itemize}
		\item[] \textbf{FR.16}: When performing level tests, a strange anomaly led to one test constantly failing. The test revealed that the player, in fact, did not begin at the first level. Due to an off-by-one error and slight miscommunication between developers, the current level depth the player was on was $i$ in some places and $i+1$ in others. As soon as the test revealed this, the problem was remedied globally.
		\item[] \textbf{FR.19}: Whenever the player uncovers a new dungeon level (including the very first level), an algorithm decides on a position in which to place the user initially. This algorithm while appearing flawless, actually had a very slight chance of placing the player in an unreachable location, surrounded by walls, doomed forever. With the automatic tests running thousands upon thousands of simulations, the bug was quickly revealed, and remedied.
		\item[] \textbf{FR.39}: Working with C++ has its benefits, but also its drawbacks. An anomaly in the way C++ handles integers revealed a very serious bug in the code, in which player armor could reach utterly ridiculous values, rendering the player effectively invincible. By simulating every possibility of armor that can be made, this bug was caught and patched. To elaborate, the reason the bug even existed was because an unsigned integer was allowed to be reduced to a negative value, which of course means that it was not reduced to a negative number and instead went to the highest value an integer can be.
	\end{itemize}


\newsection{Non-Functional Requirements Evaluation} \label{Section_NFR_Evaluation}
	The following subsections evaluate the significant non-functional qualities of Rogue Reborn.  To simplify notation, \textit{NFRT $i$} is used to denote ``Non-Functional Requirements Test $i$'' from the \href{run:../TestPlan/TestPlan.pdf}{Test Plan} document.  Note that the usability and playtesting surveys described in \nfrt{1}, \nfrt{2}, \nfrt{4}, \nfrt{7}, \nfrt{10} were not performed as a direct consequence of the time constraints imposed on the project (the \href{run:../../ProjectSchedule/rogue.gan}{Gantt Chart} schedules this survey to be released in early January, 2017).

	\subsection{Usability and Aesthetics}
		Overall, the visual appearance of the application was well-received by the Rogue Reborn stakeholders.  This was deduced through the interactions between the Rogue++ team and the \textit{SFWRENG 3XA3} instructor staff, as well as informal conversations with other colleagues.  Unfortunately, the usability survey described in \nfrt{1} will be carried out in the future, so the impressions of the general public are not yet known.\\

		Since the usability of the original \textit{Rogue} was relatively poor due to its seemingly-arbitrary key bindings, the Rogue Reborn application made goals to improve this area.  Specifically, the application featured arrow key bindings for some of player character movements in order to accommodate a more standard and intuitive keyboard layout.  However, due to the plethora of other key bindings, the Rogue++ team was \textit{not} successful in alleviating this issue completely.  A summary of the remaining non-functional test \nfrt{3} is given below.

		\nfrtc{3}
		{All strings in the Rogue Reborn source code were extracted and placed in a text file, where a developer later corrected all indicated errors that were potentially associated with a GUI output using Microsoft Word.  The script that performed the string extraction is located under the \lstinline$src/misc$ under the name \href{run:../../src/misc/stringfinder.py}{stringfinder.py}.}
		{The aforementioned script managed to located approximately 1400 strings.  After manually verifying the grammatical correctness and spelling of each string in Word, it was determined that the GUI output is free of linguistic errors.}

	\subsection{Performance}
		Mikhail

	\subsection{Robustness and Maintainability}
		Mikhail
	
	\subsection{Safety}
		Mikhail

\newsection{Comparison to Existing Implementation} \label{Section_Comparison}

	According to all collected resources of the original implementation, there were no tests done to verify the accuracy of the original product. This is somewhat understandable, all things considered. After all, the original product was released in 1980, almost 40 years ago. Since then, standards of software development were transformed from infanthood to the rigorous forms they take today.\\

	As such, the tests we have written have nothing to be compared to. 

\newsection{Unit Testing} \label{Section_UT}
	Mikhail

\newsection{Changes Due to Testing} \label{Section_Changes}
	Mikhail

\newsection{Automated Testing} \label{Section_Automated}

\subsection{Automated Testing Strategy}
For this project we elected not to use a 3rd party testing library. We made this decision to ease configuration/installation problems and reduce our dependencies, as we judged it would not be necessary. Instead a series of files (labeled test.foobar.cpp) in the repository hold tests, which are run by our custom test runner. These automated tests are run on command by executing the produced executable, or by the continuous integration script run whenever changes are pushed to the central repository. The results of these tests are automatically reported, resulting in a failed or successful build.

\subsection{Specific System Tests}
The following is a list of all automated tests in the project.

	\subsection{Automated Testing Strategy}
	For this project we elected not to use a 3rd party testing library. We made this decision to ease configuration/installation problems and reduce our dependencies, as we judged it would not be necessary. Instead a series of files (labeled test.foobar.cpp) in the repository hold tests, which are run by our custom test runner. These automated tests are run on command by executing the produced executable, or by the continuous integration script run whenever changes are pushed to the central repository. The results of these tests are automatically reported, resulting in a failed or successful build.

	\subsection{Specific System Tests}
	The following is a list of all system tests in the project.

		\begin{center}

			\begin{longtable}{ l | p{10cm} }
				\hline
				\textbf{Name:} & Amulet Construction\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate, context value\\
				\textbf{Expected Output:} & Amulet object in valid initial state\\
				\hline
				\textbf{Name:} & Armor Construction 1\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate\\
				\textbf{Expected Output:} & Armor object in valid initial state\\
				\hline
				\textbf{Name:} & Armor Construction 2\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate, context value, type value\\
				\textbf{Expected Output:} & Armor object in valid initial state\\
				\hline
				\textbf{Name:} & Armor Identification\\
				\textbf{Initial State:} & Cursed Armor\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that armor is identified\\
				\hline
				\textbf{Name:} & Armor Curse\\
				\textbf{Initial State:} & Cursed Armor\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that armor is cursed\\
				\hline
				\textbf{Name:} & Armor Enchantment\\
				\textbf{Initial State:} & Cursed Armor\\
				\textbf{Input:} & Curse level\\
				\textbf{Expected Output:} & Verification that armor enchantment is correct\\
				\hline
				\textbf{Name:} & Armor Rating\\
				\textbf{Initial State:} & Cursed Armor\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that armor rating is correct\\
				\hline
				\textbf{Name:} & Coordinate Ordering\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & (0,0) coordinate and (1,1) coordinate\\
				\textbf{Expected Output:} & Verification that (0,0) < (1,1)\\
				\hline
				\textbf{Name:} & Coordinate Equality\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Two (0,0) coordinates\\
				\textbf{Expected Output:} & Verification that the two inputs are equal\\
				\hline
				\textbf{Name:} & Coordinate Inequality\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & (0,0) coordinate and (1,1) coordinate\\
				\textbf{Expected Output:} & Verification that the two inputs are not equal\\
				\hline
				\textbf{Name:} & Coordinate Addition\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & (2,3) coordinate and (1,2) coordinate\\
				\textbf{Expected Output:} & (3,5) coordinate\\
				\hline
				\textbf{Name:} & Coordinate Subtraction\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & (2,3) coordinate and (1,2) coordinate\\
				\textbf{Expected Output:} & (1,1) coordinate\\
				\hline
				\textbf{Name:} & Feature Construction\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Symbol, coordinate, visibility, color\\
				\textbf{Expected Output:} & Feature object in valid initial state\\
				\hline
				\textbf{Name:} & Feature Symbol Check\\
				\textbf{Initial State:} & Feature with given symbol\\
				\textbf{Input:} & Symbol\\
				\textbf{Expected Output:} & Verification that feature's symbol matches given\\
				\hline
				\textbf{Name:} & Feature Invisibility Check\\
				\textbf{Initial State:} & Invisible feature\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that feature is invisible\\
				\hline
				\textbf{Name:} & Feature Visibility Check\\
				\textbf{Initial State:} & Visible feature\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that feature is visible\\
				\hline
				\textbf{Name:} & Feature Location Check\\
				\textbf{Initial State:} & Feature with given location\\
				\textbf{Input:} & Coordinate\\
				\textbf{Expected Output:} & Verification that feature's location matches given coordinate\\
				\hline
				\textbf{Name:} & Food Construction\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate and context value\\
				\textbf{Expected Output:} & Food object in valid initial state\\
				\hline
				\textbf{Name:} & Food Eating\\
				\textbf{Initial State:} & Food and player objects\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that food has increased the player's food life by an appropriate amount\\
				\hline
				\textbf{Name:} & GoldPile Construction\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate, gold amount value\\
				\textbf{Expected Output:} & GoldPile object in valid initial state\\
				\hline
				\textbf{Name:} & GoldPile Quantity Check\\
				\textbf{Initial State:} & GoldPile with given amount of gold\\
				\textbf{Input:} & Amount of gold value\\
				\textbf{Expected Output:} & Verification that gold's amount matches given amount\\
				\hline
				\textbf{Name:} & Item Construction 1\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Symbol, coordinate, context value, item class specifier, name value, psuedoname value, item type specifier, item stackability value, item throwability value, weight value\\
				\textbf{Expected Output:} & Item object in valid initial state\\
				\textbf{Name:} & Item Construction 2\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Symbol, coordinate, context value, item class specifier, name value, psuedoname value, item type specifier, item stackability value, item throwability value, weight value\\
				\textbf{Expected Output:} & Item object in valid initial state\\
				\hline
				\textbf{Name:} & Name Vector Check\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Vector of item names\\
				\textbf{Expected Output:} & Shuffled vector of item names\\
				\hline
				\textbf{Name:} & Item Curse Check\\
				\textbf{Initial State:} & Uncursed item\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that item is uncursed\\
				\hline
				\textbf{Name:} & Item Curse/Effect Check 1\\
				\textbf{Initial State:} & Uncursed item to which the cursed effect has been applied\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that item is cursed\\
				\hline
				\textbf{Name:} & Item Curse/Effect Check 2\\
				\textbf{Initial State:} & Cursed item whose curse effect has been removed\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that item is uncursed\\
				\hline
				\textbf{Name:} & Item Unindentified Check\\
				\textbf{Initial State:} & Identified item\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that item is unidentified\\
				\hline
				\textbf{Name:} & Item Identified Check\\
				\textbf{Initial State:} & Unidentified item\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that item is identified\\
				\hline
				\textbf{Name:} & Item Display-Name Check 1\\
				\textbf{Initial State:} & Unidentified item\\
				\textbf{Input:} & Psuedoname\\
				\textbf{Expected Output:} & Verification that item's display name matches psuedoname\\
				\hline
				\textbf{Name:} & Item Display-Name Check 2\\
				\textbf{Initial State:} & Identified item\\
				\textbf{Input:} & True name\\
				\textbf{Expected Output:} & Verification that item's display name matches true name\\
				\hline
				\textbf{Name:} & ItemZone Containment Check 1\\
				\textbf{Initial State:} & ItemZone with 2 items\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that ItemZone contains the first item\\
				\hline
				\textbf{Name:} & ItemZone Containment Check 2\\
				\textbf{Initial State:} & ItemZone with 2 items\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that ItemZone contains the second item\\
				\hline
				\textbf{Name:} & ItemZone Empty Check\\
				\textbf{Initial State:} & ItemZone with 2 items\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that ItemZone is not empty\\
				\hline
				\textbf{Name:} & ItemZone Size Check\\
				\textbf{Initial State:} & ItemZone with 2 items\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that ItemZone's size is 2\\
				\hline
				\textbf{Name:} & ItemZone Keybind Check 1\\
				\textbf{Initial State:} & ItemZone with 2 items\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that first item is bound to 'a' key\\
				\hline
				\textbf{Name:} & ItemZone Keybind Check 2\\
				\textbf{Initial State:} & ItemZone with 2 items\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that second item is bound to 'b' key\\
				\hline
				\textbf{Name:} & ItemZone Contents Retrieval 1\\
				\textbf{Initial State:} & ItemZone with 2 items\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Item map with exactly 1 copy of first item\\
				\hline
				\textbf{Name:} & ItemZone Contents Retrieval 2\\
				\textbf{Initial State:} & ItemZone with 2 items\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Item map with exactly 1 copy of second item\\
				\hline
				\textbf{Name:} & ItemZone Removal\\
				\textbf{Initial State:} & ItemZone with 2 items\\
				\textbf{Input:} & Removal command\\
				\textbf{Expected Output:} & ItemZone with only second item\\
				\hline
				\textbf{Name:} & ItemZone Keybind Persistence\\
				\textbf{Initial State:} & ItemZone with first item removed\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that second item is still bound to 'b'\\
				\hline
				\textbf{Name:} & ItemZone Weight Enforcement\\
				\textbf{Initial State:} & Empty ItemZone\\
				\textbf{Input:} & Attempt to add 500 pieces of armor to ItemZone\\
				\textbf{Expected Output:} & ItemZone with max-weight worth of armor\\
				\hline
				\textbf{Name:} & Level Construction\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Depth, player object\\
				\textbf{Expected Output:} & Level object in valid initial state\\
				\hline
				\textbf{Name:} & Level Depth Check\\
				\textbf{Initial State:} & Level with given depth\\
				\textbf{Input:} & Depth value\\
				\textbf{Expected Output:} & Verification that level's depth matches given value\\
				\hline
				\textbf{Name:} & Level BFSPerp Diagonal Small\\
				\textbf{Initial State:} & Empty level object\\
				\textbf{Input:} & Pair of coordinates diagonally adjacent\\
				\textbf{Expected Output:} & Path between coordinates with expected length, utilizing taxicab movemen\\
				\hline
				\textbf{Name:} & Level BFSPerp Horizontal\\
				\textbf{Initial State:} & Empty level object\\
				\textbf{Input:} & Pair of coordinates with equal y-values\\
				\textbf{Expected Output:} & Path between coordinates with expected length, utilizing taxicab movemen\\
				\hline
				\textbf{Name:} & Level BFSPerp Vertical\\
				\textbf{Initial State:} & Empty level object\\
				\textbf{Input:} & Pair of coordinates with equal x-values\\
				\textbf{Expected Output:} & Path between coordinates with expected length, utilizing taxicab movemen\\
				\hline
				\textbf{Name:} & Level BFSDiag Horizontal\\
				\textbf{Initial State:} & Empty level object\\
				\textbf{Input:} & Pair of coordinates with equal y-values\\
				\textbf{Expected Output:} & Path between coordinates with expected length, utilizing orthogonal movement\\
				\hline
				\textbf{Name:} & Level BFSDiag Vertical\\
				\textbf{Initial State:} & Empty level object\\
				\textbf{Input:} & Pair of coordinates with equal x-values\\
				\textbf{Expected Output:} & Path between coordinates with expected length, utilizing orthogonal movement\\
				\hline
				\textbf{Name:} & Level BFSPerp Diagonal\\
				\textbf{Initial State:} & Empty level object\\
				\textbf{Input:} & Pair of coordinates on diagonal line\\
				\textbf{Expected Output:} & Path between coordinates with expected length, utilizing taxicab movement\\
				\hline
				\textbf{Name:} & Level Starting Position\\
				\textbf{Initial State:} & Empty level object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Valid starting position coordinate\\
				\hline
				\textbf{Name:} & Level getAdjPassable\\
				\textbf{Initial State:} & Empty level object\\
				\textbf{Input:} & Coordinate\\
				\textbf{Expected Output:} & List of coordinates orthogonally adjacent to given coordinate\\
				\hline
				\textbf{Name:} & Level Path Generation\\
				\textbf{Initial State:} & Player object and generated level\\
				\textbf{Input:} & Series of path requests between random coordinates\\
				\textbf{Expected Output:} & Valid paths between locations\\
				\hline
				\textbf{Name:} & Level Connectedness\\
				\textbf{Initial State:} & Player object and generated level\\
				\textbf{Input:} & Series of path requests between all rooms in the level\\
				\textbf{Expected Output:} & Valid paths between each room\\
				\hline
				\textbf{Name:} & Level Staircase Check\\
				\textbf{Initial State:} & Player object and generated level\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that level contains a staircase\\
				\hline
				\textbf{Name:} & Level GoldPile Check\\
				\textbf{Initial State:} & Player object and generated level\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that level contains at least one goldpile\\
				\hline
				\textbf{Name:} & Monster Construction\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Symbol, coordinate, armor value, HP value, exp value, level value, maxHP value, name value\\
				\textbf{Expected Output:} & Monster object in valid initial state\\
				\hline
				\textbf{Name:} & Dice-Math 1\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & 1 1-sided die\\
				\textbf{Expected Output:} & Sum of values of 1\\
				\hline
				\textbf{Name:} & Dice-Math 2\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & 2 1-sided die\\
				\textbf{Expected Output:} & Sum of values of 2\\
				\hline
				\textbf{Name:} & Dice-Math 3\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & 1 2-sided die\\
				\textbf{Expected Output:} & 1 <= Sum of values <= 2\\
				\hline
				\textbf{Name:} & Dice-Math 4\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & 3 4-sided die\\
				\textbf{Expected Output:} & 3 <= Sum of values <= 12\\
				\hline
				\textbf{Name:} & Mob Armor Check\\
				\textbf{Initial State:} & Mob object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification mob armor is in valid range\\
				\hline
				\textbf{Name:} & Mob HP Check 1\\
				\textbf{Initial State:} & Mob with given HP value\\
				\textbf{Input:} & HP value\\
				\textbf{Expected Output:} & Verification mob has correct HP value\\
				\hline
				\textbf{Name:} & Mob MaxHP Check\\
				\textbf{Initial State:} & Mob with given MaxHP value\\
				\textbf{Input:} & MaxHP value\\
				\textbf{Expected Output:} & Verification mob has correct MaxHP value\\
				\hline
				\textbf{Name:} & Mob Level Check\\
				\textbf{Initial State:} & Mob with given level value\\
				\textbf{Input:} & Level value\\
				\textbf{Expected Output:} & Verification mob has correct level value\\
				\hline
				\textbf{Name:} & Mob Location Check\\
				\textbf{Initial State:} & Mob with given location\\
				\textbf{Input:} & Coordinate\\
				\textbf{Expected Output:} & Verification mob has correct location\\
				\hline
				\textbf{Name:} & Mob Name Check\\
				\textbf{Initial State:} & Mob with given name\\
				\textbf{Input:} & Name value\\
				\textbf{Expected Output:} & Verification mob has correct name\\
				\hline
				\textbf{Name:} & Mob setMaxHP\\
				\textbf{Initial State:} & Mob with default MaxHP\\
				\textbf{Input:} & setMaxHP command with MaxHP value\\
				\textbf{Expected Output:} & mob with given MaxHP value\\
				\hline
				\textbf{Name:} & Mob setcurrentHP\\
				\textbf{Initial State:} & Mob with default currentHP\\
				\textbf{Input:} & setCurrentHP command with currentHP value\\
				\textbf{Expected Output:} & mob with given currentHP value\\
				\hline
				\textbf{Name:} & Mob Dead Check 1\\
				\textbf{Initial State:} & Living Mob object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification mob is alive\\
				\hline
				\textbf{Name:} & Mob HP Check 2\\
				\textbf{Initial State:} & Living Mob object\\
				\textbf{Input:} & Hit command for >>> mob's current HP\\
				\textbf{Expected Output:} & Verification mob has HP <= 0\\
				\hline
				\textbf{Name:} & Mob Dead Check 2\\
				\textbf{Initial State:} & Dead mob object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification mob is dead\\
				\hline
				\textbf{Name:} & Monster Construction\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Symbol, coordinate\\
				\textbf{Expected Output:} & Monster object in valid initial state\\
				\hline
				\textbf{Name:} & Monster Flag/Invisibility\\
				\textbf{Initial State:} & Visible monster object\\
				\textbf{Input:} & SetFlag command to make monster invisible\\
				\textbf{Expected Output:} & Invisible monster object\\
				\hline
				\textbf{Name:} & Monster Aggrevate\\
				\textbf{Initial State:} & Idling, sleeping monster object\\
				\textbf{Input:} & Aggrevate command\\
				\textbf{Expected Output:} & Awake, chasing monster object\\
				\hline
				\textbf{Name:} & Monster Damage Calculation\\
				\textbf{Initial State:} & Monster object\\
				\textbf{Input:} & calculateDamage command\\
				\textbf{Expected Output:} & Correct amount of damage\\
				\hline
				\textbf{Name:} & Monster Hit Chance\\
				\textbf{Initial State:} & Monster and player objects\\
				\textbf{Input:} & calculateHitChange command\\
				\textbf{Expected Output:} & Hit chance in valid range\\
				\hline
				\textbf{Name:} & Monster Armor Check\\
				\textbf{Initial State:} & Monster object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that monster armor is in valid range\\
				\hline
				\textbf{Name:} & Invisible Monster Name Check\\
				\textbf{Initial State:} & Invisible uonster object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification monster has hidden name\\
				\hline
				\textbf{Name:} & Visible Monster Name Check\\
				\textbf{Initial State:} & Invisible monster object\\
				\textbf{Input:} & RemoveFlag command to make monster invisible\\
				\textbf{Expected Output:} & Verification monster has real name\\
				\hline
				\textbf{Name:} & Monster Symbol/Level Association\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Depth value\\
				\textbf{Expected Output:} & Set of symbols for monsters that are valid candidates for given depth\\
				\hline
				\textbf{Name:} & Monster Symbol/Treasure/Level Association\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Depth value\\
				\textbf{Expected Output:} & Set of symbols for monsters that are valid candidates for given depth for a treasure room\\
				\hline
				\textbf{Name:} & PlayerChar Initial Amulet Check\\
				\textbf{Initial State:} & Just initialized playerchar object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification the game does not believe the player has the amulet\\
				\hline
				\textbf{Name:} & PlayerChar Initial HP Check\\
				\textbf{Initial State:} & Just initialized playerchar object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification playerchar has full hp\\
				\hline
				\textbf{Name:} & PlayerChar Level-Up Exp\\
				\textbf{Initial State:} & Playerchar object at initial level\\
				\textbf{Input:} & Exp input into playerchar object\\
				\textbf{Expected Output:} & Playerchar object with increased level\\
				\hline
				\textbf{Name:} & PlayerChar Level-Up Manual\\
				\textbf{Initial State:} & Playerchar object\\
				\textbf{Input:} & Level-up command\\
				\textbf{Expected Output:} & Playerchar object with increased level\\
				\hline
				\textbf{Name:} & PlayerChar Damage\\
				\textbf{Initial State:} & Playerchar object at full hp\\
				\textbf{Input:} & Series of damage commands applied to playerchar object\\
				\textbf{Expected Output:} & Playerchar object with less than full hp\\
				\hline
				\textbf{Name:} & PlayerChar UnArmed 1\\
				\textbf{Initial State:} & Unarmed playerchar object\\
				\textbf{Input:} & calculateDamage command\\
				\textbf{Expected Output:} & 0 damage value\\
				\hline
				\textbf{Name:} & PlayerChar Armed\\
				\textbf{Initial State:} & Playerchar object armed with weapon\\
				\textbf{Input:} & calculateDamage command\\
				\textbf{Expected Output:} & Damage value > 0\\
				\hline
				\textbf{Name:} & PlayerChar Stow Weapon\\
				\textbf{Initial State:} & Playerchar object armed with uncursed weapon\\
				\textbf{Input:} & removeWeapon command\\
				\textbf{Expected Output:} & PlayerChar object unarmed\\
				\hline
				\textbf{Name:} & PlayerChar UnArmed 2\\
				\textbf{Initial State:} & Armed playerchar object\\
				\textbf{Input:} & removeWeapon command, then calculateDamage\\
				\textbf{Expected Output:} & 0 damage value\\
				\hline
				\textbf{Name:} & PlayerChar Remove Non-Armor\\
				\textbf{Initial State:} & Playerchar object with no armor\\
				\textbf{Input:} & removeArmor command\\
				\textbf{Expected Output:} & Boolean indicating failure to remove armor\\
				\hline
				\textbf{Name:} & PlayerChar Remove Armor\\
				\textbf{Initial State:} & Playerchar object with uncursed armor\\
				\textbf{Input:} & removeArmor command\\
				\textbf{Expected Output:} & Playerchar object without armor\\
				\hline
				\textbf{Name:} & Potion Construction 1\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate\\
				\textbf{Expected Output:} & Potion object in valid initial state\\
				\hline
				\textbf{Name:} & Potion Construction 2\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate, item context value, item type specifier\\
				\textbf{Expected Output:} & Potion object in valid initial state\\
				\hline
				\textbf{Name:} & Potion of Strength\\
				\textbf{Initial State:} & Player object\\
				\textbf{Input:} & Potion of strength\\
				\textbf{Expected Output:} & Player with strength increased by 1\\
				\hline
				\textbf{Name:} & Potion of Restore Strength\\
				\textbf{Initial State:} & Player object with reduced strength\\
				\textbf{Input:} & Potion of restore strength\\
				\textbf{Expected Output:} & Player object with pre-reduction strength\\
				\hline
				\textbf{Name:} & Potion of Healing\\
				\textbf{Initial State:} & Player object with full hp\\
				\textbf{Input:} & Potion of healing\\
				\textbf{Expected Output:} & Player object with maxHP increased by 1\\
				\hline
				\textbf{Name:} & Potion of Extra Healing\\
				\textbf{Initial State:} & Player object with full hp\\
				\textbf{Input:} & Potion of extra healing\\
				\textbf{Expected Output:} & Player object with maxHP increased by 2\\
				\hline
				\textbf{Name:} & Potion of Poison\\
				\textbf{Initial State:} & Player object with strength > 0\\
				\textbf{Input:} & Potion of poison\\
				\textbf{Expected Output:} & Player object with reduced strength\\
				\hline
				\textbf{Name:} & Potion of Raise Level\\
				\textbf{Initial State:} & Player object with less than max level\\
				\textbf{Input:} & Potion or raise level\\
				\textbf{Expected Output:} & Player object with level + 1\\
				\hline
				\textbf{Name:} & Potion of Blindness\\
				\textbf{Initial State:} & Player object without the blindness condition\\
				\textbf{Input:} & Potion of blindness\\
				\textbf{Expected Output:} & Player object with the blindness condition\\
				\hline
				\textbf{Name:} & Potion of Hallucination\\
				\textbf{Initial State:} & Player object without the hallucination condition\\
				\textbf{Input:} & Potion of hallucination\\
				\textbf{Expected Output:} & Player object with the hallucination condition\\
				\hline
				\textbf{Name:} & Potion of Detect Monster\\
				\textbf{Initial State:} & Player object without the detect-monsters condition\\
				\textbf{Input:} & Potion of detect monsters\\
				\textbf{Expected Output:} & Player object with the detect-monsters condition\\
				\hline
				\textbf{Name:} & Potion of Detect Object\\
				\textbf{Initial State:} & Player object without the detect-objects condition\\
				\textbf{Input:} & Potion of detect objects\\
				\textbf{Expected Output:} & Player object with the detect-objects condition\\
				\hline
				\textbf{Name:} & Potion of Confusion\\
				\textbf{Initial State:} & Player object without the confusion condition\\
				\textbf{Input:} & Potion of confusion\\
				\textbf{Expected Output:} & Player object with the confusion condition\\
				\hline
				\textbf{Name:} & Potion of Confusion\\
				\textbf{Initial State:} & Player object without the confusion condition\\
				\textbf{Input:} & Potion of confusion\\
				\textbf{Expected Output:} & Player object with the confusion condition\\
				\hline
				\textbf{Name:} & Potion of Levitation\\
				\textbf{Initial State:} & Player object without the levitation condition\\
				\textbf{Input:} & Potion of levitation\\
				\textbf{Expected Output:} & Player object with the levitation condition\\
				\hline
				\textbf{Name:} & Potion of Haste\\
				\textbf{Initial State:} & Player object without the haste condition\\
				\textbf{Input:} & Potion of haste\\
				\textbf{Expected Output:} & Player object with the haste condition\\
				\hline
				\textbf{Name:} & Potion of See-Invisible\\
				\textbf{Initial State:} & Player object without the invisible-sight condition\\
				\textbf{Input:} & Potion of invisible\\
				\textbf{Expected Output:} & Player object with the invisible-sight condition\\
				\hline
				\textbf{Name:} & Random Range 1\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Upper and lower bounds 0,0\\
				\textbf{Expected Output:} & 0\\
				\hline
				\textbf{Name:} & Random Range 2\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Upper and lower bounds 5,5\\
				\textbf{Expected Output:} & 5\\
				\hline
				\textbf{Name:} & Random Range 3\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Upper and lower bounds 0,60, repeated 40 times\\
				\textbf{Expected Output:} & 0 <= result <= 60\\
				\hline
				\textbf{Name:} & Random Float\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & 40 repeats\\
				\textbf{Expected Output:} & 0 <= result <= 1\\
				\hline
				\textbf{Name:} & Random Boolean\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & 10 repeats\\
				\textbf{Expected Output:} & Both true and false are generated\\
				\hline
				\textbf{Name:} & Random Percent\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & 40 repeats\\
				\textbf{Expected Output:} & 0 <= result <= 100\\
				\hline
				\textbf{Name:} & Random Position\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Two coordinates, as top-left and bottom-right of rectangle, 10 repeats\\
				\textbf{Expected Output:} & Random coordinates within the bounds\\
				\hline
				\textbf{Name:} & Ring Construction 1\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate\\
				\textbf{Expected Output:} & Ring object with valid initial state\\
				\hline
				\textbf{Name:} & Ring Construction 2\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate, item context value, type identifier\\
				\textbf{Expected Output:} & Ring object with valid initial state\\
				\hline
				\textbf{Name:} & Ring of Stealth\\
				\textbf{Initial State:} & Player object without stealth condition\\
				\textbf{Input:} & Ring of stealth\\
				\textbf{Expected Output:} & Player object with the stealth condition\\
				\hline
				\textbf{Name:} & Ring of Stealth Deactivate\\
				\textbf{Initial State:} & Player object with ring of stealth\\
				\textbf{Input:} & Remove ring\\
				\textbf{Expected Output:} & Player object without the stealth condition\\
				\hline
				\textbf{Name:} & Ring of Teleportation\\
				\textbf{Initial State:} & Player object without random teleportation condition\\
				\textbf{Input:} & Ring of teleportation\\
				\textbf{Expected Output:} & Player object with the random teleportation condition\\
				\hline
				\textbf{Name:} & Ring of Teleportation Deactivate\\
				\textbf{Initial State:} & Player object with ring of teleportation\\
				\textbf{Input:} & Remove ring\\
				\textbf{Expected Output:} & Player object without the random teleportation condition\\
				\hline
				\textbf{Name:} & Ring of Regeneration\\
				\textbf{Initial State:} & Player object without regeneration condition\\
				\textbf{Input:} & Ring of regeneration\\
				\textbf{Expected Output:} & Player object with the regeneration condition\\
				\hline
				\textbf{Name:} & Ring of Regeneration Deactivate\\
				\textbf{Initial State:} & Player object with ring of regeneration\\
				\textbf{Input:} & Remove ring\\
				\textbf{Expected Output:} & Player object without the regeneration condition\\
				\hline
				\textbf{Name:} & Ring of Digestion\\
				\textbf{Initial State:} & Player object without digestion condition\\
				\textbf{Input:} & Ring of digestion\\
				\textbf{Expected Output:} & Player object with the digestion condition\\
				\hline
				\textbf{Name:} & Ring of Digestion Deactivate\\
				\textbf{Initial State:} & Player object with ring of digestion\\
				\textbf{Input:} & Remove ring\\
				\textbf{Expected Output:} & Player object without the digestion condition\\
				\hline
				\textbf{Name:} & Ring of Dexterity\\
				\textbf{Initial State:} & Player object\\
				\textbf{Input:} & Ring of dexterity\\
				\textbf{Expected Output:} & Player object with dexterity increased by the appropriate amount\\
				\hline
				\textbf{Name:} & Ring of Dexterity Deactivate\\
				\textbf{Initial State:} & Player object with ring of dexterity\\
				\textbf{Input:} & Remove ring\\
				\textbf{Expected Output:} & Player object with normal dexterity\\
				\hline
				\textbf{Name:} & Ring of Adornment\\
				\textbf{Initial State:} & Player object\\
				\textbf{Input:} & Ring of adornment\\
				\textbf{Expected Output:} & Identical player object\\
				\hline
				\textbf{Name:} & Ring of Adornment\\
				\textbf{Initial State:} & Player object with ring of adornment\\
				\textbf{Input:} & Remove ring\\
				\textbf{Expected Output:} & Identical player object\\
				\hline
				\textbf{Name:} & Ring of See-Invisible\\
				\textbf{Initial State:} & Player object without the see-invisible condition\\
				\textbf{Input:} & Ring of see-invisible\\
				\textbf{Expected Output:} & Player object with the see-invisible condition\\
				\hline
				\textbf{Name:} & Ring of See-Invisible Deactivate\\
				\textbf{Initial State:} & Player object with ring of see-invisible\\
				\textbf{Input:} & Remove ring\\
				\textbf{Expected Output:} & Player object without the see-invisible condition\\
				\hline
				\textbf{Name:} & Ring of Maintain-Armor\\
				\textbf{Initial State:} & Player object without the maintain-armor condition\\
				\textbf{Input:} & Ring of maintain-armor\\
				\textbf{Expected Output:} & Player object with the maintain-armor condition\\
				\hline
				\textbf{Name:} & Ring of Maintain-Armor Deactivate\\
				\textbf{Initial State:} & Player object with ring of maintain-armor\\
				\textbf{Input:} & Remove ring\\
				\textbf{Expected Output:} & Player object without the maintain-armor condition\\
				\hline
				\textbf{Name:} & Ring of Searching\\
				\textbf{Initial State:} & Player object without the auto-search condition\\
				\textbf{Input:} & Ring of searching\\
				\textbf{Expected Output:} & Player object with the auto-search condition\\
				\hline
				\textbf{Name:} & Ring of Searching Deactivate\\
				\textbf{Initial State:} & Player object with ring of searching\\
				\textbf{Input:} & Remove ring\\
				\textbf{Expected Output:} & Player object without the auto-search condition\\
				\hline
				\textbf{Name:} & Room Construction Check 1\\
				\textbf{Initial State:} & Randomly generated room\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that room's size is in valid range\\
				\hline
				\textbf{Name:} & Room Construction Check 2\\
				\textbf{Initial State:} & Randomly generated room\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that room edges are within valid bounds\\
				\hline
				\textbf{Name:} & Scroll Construction 1\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate\\
				\textbf{Expected Output:} & Scroll object in valid initial state\\
				\hline
				\textbf{Name:} & Scroll Construction 2\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate, item context value, type identifier\\
				\textbf{Expected Output:} & Scroll object in valid initial state\\
				\hline
				\textbf{Name:} & Scroll PseudoNames\\
				\textbf{Initial State:} & Scrolls are uninitialized\\
				\textbf{Input:} & initializeScrollNames command\\
				\textbf{Expected Output:} & Vector of valid scroll psuedonames\\
				\hline
				\textbf{Name:} & Scroll of Protect Armor\\
				\textbf{Initial State:} & Player with cursed armor \\
				\textbf{Input:} & Scroll of protect armor\\
				\textbf{Expected Output:} & Player with uncursed armor with protect-armor effect\\
				\hline
				\textbf{Name:} & Scroll of Hold Monster\\
				\textbf{Initial State:} & Monster without the held flag\\
				\textbf{Input:} & Scroll of hold monster\\
				\textbf{Expected Output:} & Monster with the held flag\\
				\hline
				\textbf{Name:} & Scroll of Enchant Weapon\\
				\textbf{Initial State:} & Player with weapon\\
				\textbf{Input:} & Scroll of enchant weapon\\
				\textbf{Expected Output:} & Player with uncursed weapon with higher enchant level\\
				\hline
				\textbf{Name:} & Scroll of Enchant Armor\\
				\textbf{Initial State:} & Player with armor\\
				\textbf{Input:} & Scroll of enchant armor\\
				\textbf{Expected Output:} & Player with uncursed armor with higher enchant level\\
				\hline
				\textbf{Name:} & Scroll of Identity\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Scroll identity\\
				\textbf{Expected Output:} & No exceptions\\
				\hline
				\textbf{Name:} & Scroll of Teleportation\\
				\textbf{Initial State:} & Player at coordinate (0,0)\\
				\textbf{Input:} & Scroll of teleportation\\
				\textbf{Expected Output:} & Player at coordinate != (0,0)\\
				\hline
				\textbf{Name:} & Scroll of Sleep\\
				\textbf{Initial State:} & Player without the sleep condition\\
				\textbf{Input:} & Scroll of sleep\\
				\textbf{Expected Output:} & Player with the sleep condition\\
				\hline
				\textbf{Name:} & Scroll of Scare Monster\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Scroll of scare monster\\
				\textbf{Expected Output:} & No exceptions\\
				\hline
				\textbf{Name:} & Scroll of Remove Curse\\
				\textbf{Initial State:} & Player with cursed weapon\\
				\textbf{Input:} & Scroll of remove curse\\
				\textbf{Expected Output:} & Player with uncursed weapon\\
				\hline
				\textbf{Name:} & Scroll of Create Monster\\
				\textbf{Initial State:} & Level object\\
				\textbf{Input:} & Scroll of create monster\\
				\textbf{Expected Output:} & Level with 1 additional monster\\
				\hline
				\textbf{Name:} & Scroll of Aggravate Monster\\
				\textbf{Initial State:} & Level with sleeping monsters\\
				\textbf{Input:} & Scroll of aggravate monster\\
				\textbf{Expected Output:} & Level with no sleeping monsters\\
				\hline
				\textbf{Name:} & Scroll of Magic Mapping\\
				\textbf{Initial State:} & Unrevealed level\\
				\textbf{Input:} & Scroll of magic mapping\\
				\textbf{Expected Output:} & Level where all tiles have been revealed\\
				\hline
				\textbf{Name:} & Scroll of Confuse Monster\\
				\textbf{Initial State:} & Player without the confuse-monster condition\\
				\textbf{Input:} & Scroll of confuse monster\\
				\textbf{Expected Output:} & Player with the confuse-monster condition\\
				\hline
				\textbf{Name:} & Stair Construction\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate, direction value\\
				\textbf{Expected Output:} & Stair object in valid initial state\\
				\hline
				\textbf{Name:} & Stair Direction Check\\
				\textbf{Initial State:} & Stair constructed with direction\\
				\textbf{Input:} & Direction value\\
				\textbf{Expected Output:} & Verification stair has given direction value\\
				\hline
				\textbf{Name:} & Floor Passability Check\\
				\textbf{Initial State:} & Floor object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification floor is passable\\
				\hline
				\textbf{Name:} & Floor Symbol Check\\
				\textbf{Initial State:} & Floor object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification floor has correct symbol\\
				\hline
				\textbf{Name:} & Floor Transparency Check\\
				\textbf{Initial State:} & Floor object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification floor is transparent\\
				\hline
				\textbf{Name:} & Wall Passability Check\\
				\textbf{Initial State:} & Wall object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification wall is not passable\\
				\hline
				\textbf{Name:} & Wall Symbol Check\\
				\textbf{Initial State:} & Wall object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification wall has correct symbol\\
				\hline
				\textbf{Name:} & Wall Opacity Check\\
				\textbf{Initial State:} & Wall object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification wall is transparent\\
				\textbf{Name:} & Corridor Passability Check\\
				\textbf{Initial State:} & Corridor object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification corridor is passable\\
				\hline
				\textbf{Name:} & Corridor Symbol Check\\
				\textbf{Initial State:} & Corridor object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification corrido has correct symbol\\
				\hline
				\textbf{Name:} & Corridor Transparency Check\\
				\textbf{Initial State:} & Corridor object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification corridor has special corridor transparency\\
				\hline
				\textbf{Name:} & Door Passability Check\\
				\textbf{Initial State:} & Door object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification door is not passable\\
				\hline
				\textbf{Name:} & Door Symbol Check\\
				\textbf{Initial State:} & Door object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification corridor has correct symbol\\
				\hline
				\textbf{Name:} & Door Transparency Check\\
				\textbf{Initial State:} & Door object\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification Door has special corridor transparency\\
				\hline
				\textbf{Name:} & Door Trap\\
				\textbf{Initial State:} & Player and level\\
				\textbf{Input:} & Door trap\\
				\textbf{Expected Output:} & Player at a level with depth + 1\\
				\hline
				\textbf{Name:} & Rust Trap\\
				\textbf{Initial State:} & Player with enchanted weapon\\
				\textbf{Input:} & Rust trap\\
				\textbf{Expected Output:} & Player with unenchanted weapon\\
				\hline
				\textbf{Name:} & Sleep Trap\\
				\textbf{Initial State:} & Player without the sleep condition\\
				\textbf{Input:} & Sleep trap\\
				\textbf{Expected Output:} & Player with the sleep condition\\
				\hline
				\textbf{Name:} & Bear Trap\\
				\textbf{Initial State:} & Player without the immobilized condition\\
				\textbf{Input:} & Bear trap\\
				\textbf{Expected Output:} & Player with the immobilized condition\\
				\hline
				\textbf{Name:} & Teleport Trap\\
				\textbf{Initial State:} & Player\\
				\textbf{Input:} & Teleport trap\\
				\textbf{Expected Output:} & Player at a different location\\
				\hline
				\textbf{Name:} & Dart Trap\\
				\textbf{Initial State:} & Player\\
				\textbf{Input:} & Dart trap\\
				\textbf{Expected Output:} & Player with less hp\\
				\hline
				\textbf{Name:} & Tunnel Digging\\
				\textbf{Initial State:} & Level and pair of unconnected rooms\\
				\textbf{Input:} & Dig command\\
				\textbf{Expected Output:} & Valid path between the two rooms\\
				\hline
				\textbf{Name:} & Open Inventory Screen\\
				\textbf{Initial State:} & Playstate, player, empty level\\
				\textbf{Input:} & Inventory key\\
				\textbf{Expected Output:} & Inventory screen\\
				\hline
				\textbf{Name:} & Close Inventory Screen\\
				\textbf{Initial State:} & Inventory screen, player, empty level\\
				\textbf{Input:} & Exit key\\
				\textbf{Expected Output:} & Playstate\\
				\hline
				\textbf{Name:} & Movement\\
				\textbf{Initial State:} & Playstate, player, empty level\\
				\textbf{Input:} & Movement key\\
				\textbf{Expected Output:} & Player should be in expected location in the level\\
				\hline
				\textbf{Name:} & Open Status Screen\\
				\textbf{Initial State:} & Playstate, player, empty level\\
				\textbf{Input:} & Status key\\
				\textbf{Expected Output:} & Status screen\\
				\hline
				\textbf{Name:} & Exit Status Screen\\
				\textbf{Initial State:} & Status Screen, player, empty level\\
				\textbf{Input:} & Exit key\\
				\textbf{Expected Output:} & Playstate\\
				\hline
				\textbf{Name:} & No Wand Zap\\
				\textbf{Initial State:} & Playstate, player with no wand\\
				\textbf{Input:} & Zap key\\
				\textbf{Expected Output:} & Unchanged playstate\\
				\hline
				\textbf{Name:} & Zap Wand Select\\
				\textbf{Initial State:} & Playstate, player with wand, empty level \\
				\textbf{Input:} & Zap key, then direction key\\
				\textbf{Expected Output:} & Inventory Screen\\
				\hline
				\textbf{Name:} & Zap Wand Fire 1\\
				\textbf{Initial State:} & Inventory wand select\\
				\textbf{Input:} & Item select hotkey\\
				\textbf{Expected Output:} & Playstate\\
				\hline
				\textbf{Name:} & Zap Wand Fire 2\\
				\textbf{Initial State:} & Inventory wand select\\
				\textbf{Input:} & Item select hotkey\\
				\textbf{Expected Output:} & wand with charges - 1\\
				\hline
				\textbf{Name:} & Game Quit\\
				\textbf{Initial State:} & Playstate\\
				\textbf{Input:} & Quit key and confirmation key\\
				\textbf{Expected Output:} & RIPScreen\\
				\hline
				\textbf{Name:} & Wand Construction 1\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate\\
				\textbf{Expected Output:} & Wand in valid initial state\\
				\hline
				\textbf{Name:} & Wand Construction 2\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate, item context value, type specifier\\
				\textbf{Expected Output:} & Wand in valid initial state\\
				\hline
				\textbf{Name:} & Wand of Teleport Away\\
				\textbf{Initial State:} & Player, nearby monster\\
				\textbf{Input:} & Wand of teleport away\\
				\textbf{Expected Output:} & Monster has distance to player >= 20\\
				\hline
				\textbf{Name:} & Wand of Slow Monster\\
				\textbf{Initial State:} & Player, monster without slowed flag\\
				\textbf{Input:} & Wand of slow monster\\
				\textbf{Expected Output:} & Monster has slowed flag\\
				\hline
				\textbf{Name:} & Wand of Invisibility\\
				\textbf{Initial State:} & Player, monster without invisible flag\\
				\textbf{Input:} & Wand of invisibility\\
				\textbf{Expected Output:} & Monster with invisible flag\\
				\hline
				\textbf{Name:} & Wand of Polymorph\\
				\textbf{Initial State:} & Player, monster\\
				\textbf{Input:} & Wand of polymorph\\
				\textbf{Expected Output:} & Different monster at previous monster's locations\\
				\hline
				\textbf{Name:} & Wand of Haste Monster\\
				\textbf{Initial State:} & Player, monster without haste flag\\
				\textbf{Input:} & Wand of haste monster\\
				\textbf{Expected Output:} & Monster with haste flag\\
				\hline
				\textbf{Name:} & Wand of Magic Missile\\
				\textbf{Initial State:} & Player, monster\\
				\textbf{Input:} & Wand of magic missile\\
				\textbf{Expected Output:} & Monster with reduced hp\\
				\hline
				\textbf{Name:} & Wand of Cancellation\\
				\textbf{Initial State:} & Player, monster without cancelled flag\\
				\textbf{Input:} & Wand of cancellation\\
				\textbf{Expected Output:} & Monster with cancelled flag\\
				\hline
				\textbf{Name:} & Wand of Do Nothing\\
				\textbf{Initial State:} & Player, monster\\
				\textbf{Input:} & Wand of do nothing\\
				\textbf{Expected Output:} & No exceptions\\
				\hline
				\textbf{Name:} & Wand of Drain Life\\
				\textbf{Initial State:} & Player with reduced health, monster\\
				\textbf{Input:} & Wand of drain life\\
				\textbf{Expected Output:} & Player with increased health, monster with reduced health\\
				\hline
				\textbf{Name:} & Wand of Cold\\
				\textbf{Initial State:} & Player, monster\\
				\textbf{Input:} & Wand of cold\\
				\textbf{Expected Output:} & No exceptions\\
				\hline
				\textbf{Name:} & Wand of Fire\\
				\textbf{Initial State:} & Player, monster\\
				\textbf{Input:} & Wand of fire\\
				\textbf{Expected Output:} & No exceptions\\
				\hline
				\textbf{Name:} & Weapon Construction 1\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate\\
				\textbf{Expected Output:} & Weapon in valid initial state\\
				\hline
				\textbf{Name:} & Weapon Construction 2\\
				\textbf{Initial State:} & None\\
				\textbf{Input:} & Coordinate, item context value, type specifier\\
				\textbf{Expected Output:} & Weapon in valid initial state\\
				\hline
				\textbf{Name:} & Weapon Identification Check\\
				\textbf{Initial State:} & Identified weapon\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that weapon is identified\\
				\hline
				\textbf{Name:} & Weapon Curse Check\\
				\textbf{Initial State:} & Cursed weapon\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that weapon is cursed\\
				\hline
				\textbf{Name:} & Weapon Name Check\\
				\textbf{Initial State:} & Weapon\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that weapon has valid name\\
				\hline
				\textbf{Name:} & Weapon Enchantment Check\\
				\textbf{Initial State:} & Cursed weapon\\
				\textbf{Input:} & None\\
				\textbf{Expected Output:} & Verification that weapon has expected enchantment values\\
				\hline

			\end{longtable}

		\end{center}

\newsection{Trace to Requirements} \label{Section_R_Trace}

	The following table maps each implemented test file to a set of functional and non-functional requirements 

	\begin{table}[h!]
		\caption{\bf Test-Requirement Trace}
		\label{TblMH}
		\bigskip
		\centering
		\begin{longtable}{lr}
			\hline
			File & Related Requirement(s)\\
			\hline
			test.amulet.cpp 		& FR.25\\
			test.armor.cpp 			& FR.29, FR.34, FR.39,\\
			test.coord.cpp 			& FR.17\\
			test.feature.cpp 		& FR.5, FR.13, FR.14, FR.15, FR.25, FR.31\\
			test.food.cpp 			& FR.5, FR.31\\
			test.goldpile.cpp 		& FR.5\\
			test.item.cpp 			& FR.5, FR.13, FR.14, FR.15, FR.25, FR.30 FR.31\\
			test.itemzone.cpp 		& FR.5, FR.9, FR.26\\
			test.level.cpp 			& FR.16-19\\
			test.levelgen.cpp 		& FR.16-19\\
			test.main.cpp 			& Put everything together\\
			test.mob.cpp 			& FR.37, FR.38, FR.39\\
			test.monster.cpp 		& FR.35-39\\
			test.playerchar.cpp 	& FR.9-15, FR.26-34, NFR.5\\
			test.potion.cpp 		& FR.5, FR.13, FR.14, FR.15, FR.25, FR.31\\
			test.ring.cpp 			& FR.5, FR.13, FR.14, FR.15, FR.25, FR.31\\
			test.room.cpp 			& FR.17, FR.18, FR.19, FR.21\\
			test.scroll.cpp 		& FR.5, FR.13, FR.14, FR.15, FR.25, FR.31\\\\
			test.stairs.cpp 		& FR.18, FR.19\\
			test.terrain.cpp 		& FR.13, FR.15, FR.18, FR.19, FR.23, FR.24\\
			test.testable.cpp 		& Defines test-suite\\
			test.testable.h 		& Defines test-suite\\
			test.trap.cpp 			& FR.12, FR.15, FR.19, FR.20, FR.23, FR.24, FR.34\\
			test.tunnel.cpp 		& FR.17, FR.19\\
			test.uistate.cpp 		& FR.1-4, FR.6-10, NFR.1, NFR.3, NFR.5\\
			test.wand.cpp 			& FR.5, FR.13, FR.14, FR.15, FR.25, FR.31\\
			test.weapon.cpp 		& FR.5, FR.13, FR.14, FR.15, FR.25, FR.31\\
			\hline
		\end{longtable}
	\end{table}

\newsection{Trace to Modules} \label{Section_M_Trace}

	The following table re-iterates the modules of the project, along with their respective domain and module ID. The module IDs are used to refer to modules in the trace. More about the modules can be found in the Module Guide.\\

	\begin{table}[H]
		\caption{\bf Module Hierarchy}
		\label{TblMH}
		\bigskip
		\centering
		\begin{tabular}{p{0.3\textwidth} p{0.5\textwidth} R{0.10\textwidth}}
			\toprule
			\textbf{Level 1} & \multicolumn{2}{l}{\textbf{Level 2}}\\
			\midrule

			\multirow{1}{0.3\textwidth}{Hardware-Hiding Module}
			& \mdprint{BasicIO}\\
			& \mdprint{Doryen}\\
			& \mdprint{Input Format}\\
			\midrule

			\multirow{1}{0.3\textwidth}{Behaviour-Hiding Module}
			& \mdprint{External}\\
			& \mdprint{Item}\\
			& \mdprint{Level}\\
			& \mdprint{LevelGen}\\
			& \mdprint{MainMenu}\\            
			& \mdprint{Mob}\\  
			& \mdprint{Monster}\\
			& \mdprint{PlayerChar}\\
			& \mdprint{RipScreen}\\
			& \mdprint{PlayState}\\
			& \mdprint{SaveScreen}\\
			& \mdprint{UIState}\\
			\midrule

			\multirow{1}{0.3\textwidth}{Software Decision Module}
			& \mdprint{Coord}\\
			& \mdprint{Feature}\\
			& \mdprint{ItemZone}\\          
			& \mdprint{MasterController}\\
			& \mdprint{Random}\\
			& \mdprint{Terrain}\\
			\bottomrule
		\end{tabular}
		 \setcounter{mnum}{0}
	\end{table}

	%I am but a comment

	The following table maps test files, which implement tests, to specific modules, given by their IDs.\\

	\begin{table}[H]
		\caption{\bf Test-Module Trace}
		\label{TblMH}
		\bigskip
		\centering
		\begin{longtable}{lr}
			\hline
			File & Related Module(s)\\
			\hline
            test.amulet.cpp         & M7, M13, M15\\
            test.armor.cpp          & M5, M9, M11\\
            test.coord.cpp          & M2, M5, M6, M7, M16, M20\\
            test.feature.cpp        & M5, M11, M17, M18\\
            test.food.cpp           & M5, M6, M7, M11, M13\\
            test.goldpile.cpp       & M5, M6, M7, M10, M11, M17, M18\\
            test.item.cpp           & M5, M17\\
            test.itemzone.cpp       & M5, M6, M16, M17, M18\\
            test.level.cpp          & M5, M6, M10, M11, M16, M17, M20\\
            test.levelgen.cpp       & M5, M6, M10, M16, M17, M20, M21\\
            test.main.cpp           & None (Puts everything together)\\
            test.mob.cpp            & M9, M10, M11, M13, M15, M16\\
            test.monster.cpp        & M9, M10, M16\\
            test.playerchar.cpp     & M5, M6, M9, M11, M12, M13, M15, M16, M17, M18, M19\\
            test.potion.cpp         & M5, M6, M7, M10, M11, M17, M18\\
            test.ring.cpp           & M5, M6, M7, M10, M11, M17, M18\\
            test.room.cpp           & M6, M7, M16, M20\\
            test.scroll.cpp         & M5, M6, M7, M10, M11, M17, M18\\
            test.stairs.cpp         & M7, M17, M19, M21\\
            test.terrain.cpp        & M6, M7, M20, M21\\
            test.testable.cpp       & Defines test-suite\\
            test.testable.h         & Defines test-suite\\
            test.trap.cpp           & M6, M7, M11, M15, M17\\
            test.tunnel.cpp         & M5, M6, M16\\
            test.uistate.cpp        & M4, M8, M12, M13, M15, M19\\
            test.wand.cpp           & M5, M6, M7, M10, M11, M17, M18\\
            test.weapon.cpp         & M5, M6, M7, M10, M11, M17, M18\\
			\hline
		\end{longtable}
	\end{table}



\newsection{Code Coverage Metrics} \label{Section_Metrics}
	By looking at the test-requirements matrix, and also cross-referencing the test-module trace above with the module-requirements trace given in the Module Guide, it is possible to determine exactly which functional and non-functional requirements were satisfied with the test cases we created.\\

	As can be expected, near \textbf{complete coverage} of both functional and non-functional requirements is achieved. Except for a few non-functional requirements, the modules and direct requirements reflected in the test cases offer a complete coverage of the requirements. Some (in particular, non-functional) requirements are nigh impossible to test using code. An example includes NFR.2: "The Rogue Reborn game shall be fun and entertaining." Whatever software exists that can determine such a thing would never pass the Turing test, and thus can be deemed an impossibility as of current technology. But while it is impossible to test with code, such a thing is easily testable with human playtesters.\\

	Along with NFR.2, several non-functional requirements were not feasible to assert with software, but all were correctly proven by other means, most of which involved manual human labor.\\

	To expand on the previous statements, we encountered some requirements where the achievable target was difficult to materialize, but still algorithmic and computational in nature. A prime example of this is the luminosity constraint, which ruled that no two consecutive frames may have a change in brightness greater than some defined delta. In order to properly measure this, we had to go outside of the program, and write a separate script to do the hard work. We used python to calculate the pixel-accurate luminosity of some key screenshots, and using the calculation proposed by the non-functional requirement, arrived at correct results. The results were deemed close enough to the predefined delta, which itself was based more or less on our intuition.

%\bibliographystyle{plainnat}

%\bibliography{TestReport2}

\end{document}
